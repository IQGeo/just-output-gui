(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["jo"] = factory();
	else
		root["jo"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/bluebird/js/browser/bluebird.js":
/*!******************************************************!*\
  !*** ./node_modules/bluebird/js/browser/bluebird.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process, global, setImmediate) {/* @preserve\n * The MIT License (MIT)\n * \n * Copyright (c) 2013-2017 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n/**\n * bluebird build version 3.5.1\n * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each\n*/\n!function (e) {\n    if (true) module.exports = e();else { var f; }\n}(function () {\n    var define, module, exports;return function e(t, n, r) {\n        function s(o, u) {\n            if (!n[o]) {\n                if (!t[o]) {\n                    var a = typeof _dereq_ == \"function\" && _dereq_;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error(\"Cannot find module '\" + o + \"'\");throw f.code = \"MODULE_NOT_FOUND\", f;\n                }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {\n                    var n = t[o][1][e];return s(n ? n : e);\n                }, l, l.exports, e, t, n, r);\n            }return n[o].exports;\n        }var i = typeof _dereq_ == \"function\" && _dereq_;for (var o = 0; o < r.length; o++) s(r[o]);return s;\n    }({ 1: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise) {\n                var SomePromiseArray = Promise._SomePromiseArray;\n                function any(promises) {\n                    var ret = new SomePromiseArray(promises);\n                    var promise = ret.promise();\n                    ret.setHowMany(1);\n                    ret.setUnwrap();\n                    ret.init();\n                    return promise;\n                }\n\n                Promise.any = function (promises) {\n                    return any(promises);\n                };\n\n                Promise.prototype.any = function () {\n                    return any(this);\n                };\n            };\n        }, {}], 2: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            var firstLineError;\n            try {\n                throw new Error();\n            } catch (e) {\n                firstLineError = e;\n            }\n            var schedule = _dereq_(\"./schedule\");\n            var Queue = _dereq_(\"./queue\");\n            var util = _dereq_(\"./util\");\n\n            function Async() {\n                this._customScheduler = false;\n                this._isTickUsed = false;\n                this._lateQueue = new Queue(16);\n                this._normalQueue = new Queue(16);\n                this._haveDrainedQueues = false;\n                this._trampolineEnabled = true;\n                var self = this;\n                this.drainQueues = function () {\n                    self._drainQueues();\n                };\n                this._schedule = schedule;\n            }\n\n            Async.prototype.setScheduler = function (fn) {\n                var prev = this._schedule;\n                this._schedule = fn;\n                this._customScheduler = true;\n                return prev;\n            };\n\n            Async.prototype.hasCustomScheduler = function () {\n                return this._customScheduler;\n            };\n\n            Async.prototype.enableTrampoline = function () {\n                this._trampolineEnabled = true;\n            };\n\n            Async.prototype.disableTrampolineIfNecessary = function () {\n                if (util.hasDevTools) {\n                    this._trampolineEnabled = false;\n                }\n            };\n\n            Async.prototype.haveItemsQueued = function () {\n                return this._isTickUsed || this._haveDrainedQueues;\n            };\n\n            Async.prototype.fatalError = function (e, isNode) {\n                if (isNode) {\n                    process.stderr.write(\"Fatal \" + (e instanceof Error ? e.stack : e) + \"\\n\");\n                    process.exit(2);\n                } else {\n                    this.throwLater(e);\n                }\n            };\n\n            Async.prototype.throwLater = function (fn, arg) {\n                if (arguments.length === 1) {\n                    arg = fn;\n                    fn = function () {\n                        throw arg;\n                    };\n                }\n                if (typeof setTimeout !== \"undefined\") {\n                    setTimeout(function () {\n                        fn(arg);\n                    }, 0);\n                } else try {\n                    this._schedule(function () {\n                        fn(arg);\n                    });\n                } catch (e) {\n                    throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n                }\n            };\n\n            function AsyncInvokeLater(fn, receiver, arg) {\n                this._lateQueue.push(fn, receiver, arg);\n                this._queueTick();\n            }\n\n            function AsyncInvoke(fn, receiver, arg) {\n                this._normalQueue.push(fn, receiver, arg);\n                this._queueTick();\n            }\n\n            function AsyncSettlePromises(promise) {\n                this._normalQueue._pushOne(promise);\n                this._queueTick();\n            }\n\n            if (!util.hasDevTools) {\n                Async.prototype.invokeLater = AsyncInvokeLater;\n                Async.prototype.invoke = AsyncInvoke;\n                Async.prototype.settlePromises = AsyncSettlePromises;\n            } else {\n                Async.prototype.invokeLater = function (fn, receiver, arg) {\n                    if (this._trampolineEnabled) {\n                        AsyncInvokeLater.call(this, fn, receiver, arg);\n                    } else {\n                        this._schedule(function () {\n                            setTimeout(function () {\n                                fn.call(receiver, arg);\n                            }, 100);\n                        });\n                    }\n                };\n\n                Async.prototype.invoke = function (fn, receiver, arg) {\n                    if (this._trampolineEnabled) {\n                        AsyncInvoke.call(this, fn, receiver, arg);\n                    } else {\n                        this._schedule(function () {\n                            fn.call(receiver, arg);\n                        });\n                    }\n                };\n\n                Async.prototype.settlePromises = function (promise) {\n                    if (this._trampolineEnabled) {\n                        AsyncSettlePromises.call(this, promise);\n                    } else {\n                        this._schedule(function () {\n                            promise._settlePromises();\n                        });\n                    }\n                };\n            }\n\n            Async.prototype._drainQueue = function (queue) {\n                while (queue.length() > 0) {\n                    var fn = queue.shift();\n                    if (typeof fn !== \"function\") {\n                        fn._settlePromises();\n                        continue;\n                    }\n                    var receiver = queue.shift();\n                    var arg = queue.shift();\n                    fn.call(receiver, arg);\n                }\n            };\n\n            Async.prototype._drainQueues = function () {\n                this._drainQueue(this._normalQueue);\n                this._reset();\n                this._haveDrainedQueues = true;\n                this._drainQueue(this._lateQueue);\n            };\n\n            Async.prototype._queueTick = function () {\n                if (!this._isTickUsed) {\n                    this._isTickUsed = true;\n                    this._schedule(this.drainQueues);\n                }\n            };\n\n            Async.prototype._reset = function () {\n                this._isTickUsed = false;\n            };\n\n            module.exports = Async;\n            module.exports.firstLineError = firstLineError;\n        }, { \"./queue\": 26, \"./schedule\": 29, \"./util\": 36 }], 3: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, INTERNAL, tryConvertToPromise, debug) {\n                var calledBind = false;\n                var rejectThis = function (_, e) {\n                    this._reject(e);\n                };\n\n                var targetRejected = function (e, context) {\n                    context.promiseRejectionQueued = true;\n                    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);\n                };\n\n                var bindingResolved = function (thisArg, context) {\n                    if ((this._bitField & 50397184) === 0) {\n                        this._resolveCallback(context.target);\n                    }\n                };\n\n                var bindingRejected = function (e, context) {\n                    if (!context.promiseRejectionQueued) this._reject(e);\n                };\n\n                Promise.prototype.bind = function (thisArg) {\n                    if (!calledBind) {\n                        calledBind = true;\n                        Promise.prototype._propagateFrom = debug.propagateFromFunction();\n                        Promise.prototype._boundValue = debug.boundValueFunction();\n                    }\n                    var maybePromise = tryConvertToPromise(thisArg);\n                    var ret = new Promise(INTERNAL);\n                    ret._propagateFrom(this, 1);\n                    var target = this._target();\n                    ret._setBoundTo(maybePromise);\n                    if (maybePromise instanceof Promise) {\n                        var context = {\n                            promiseRejectionQueued: false,\n                            promise: ret,\n                            target: target,\n                            bindingPromise: maybePromise\n                        };\n                        target._then(INTERNAL, targetRejected, undefined, ret, context);\n                        maybePromise._then(bindingResolved, bindingRejected, undefined, ret, context);\n                        ret._setOnCancel(maybePromise);\n                    } else {\n                        ret._resolveCallback(target);\n                    }\n                    return ret;\n                };\n\n                Promise.prototype._setBoundTo = function (obj) {\n                    if (obj !== undefined) {\n                        this._bitField = this._bitField | 2097152;\n                        this._boundTo = obj;\n                    } else {\n                        this._bitField = this._bitField & ~2097152;\n                    }\n                };\n\n                Promise.prototype._isBound = function () {\n                    return (this._bitField & 2097152) === 2097152;\n                };\n\n                Promise.bind = function (thisArg, value) {\n                    return Promise.resolve(value).bind(thisArg);\n                };\n            };\n        }, {}], 4: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            var old;\n            if (typeof Promise !== \"undefined\") old = Promise;\n            function noConflict() {\n                try {\n                    if (Promise === bluebird) Promise = old;\n                } catch (e) {}\n                return bluebird;\n            }\n            var bluebird = _dereq_(\"./promise\")();\n            bluebird.noConflict = noConflict;\n            module.exports = bluebird;\n        }, { \"./promise\": 22 }], 5: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            var cr = Object.create;\n            if (cr) {\n                var callerCache = cr(null);\n                var getterCache = cr(null);\n                callerCache[\" size\"] = getterCache[\" size\"] = 0;\n            }\n\n            module.exports = function (Promise) {\n                var util = _dereq_(\"./util\");\n                var canEvaluate = util.canEvaluate;\n                var isIdentifier = util.isIdentifier;\n\n                var getMethodCaller;\n                var getGetter;\n                if (false) { var getCompiled, makeGetter, makeMethodCaller; }\n\n                function ensureMethod(obj, methodName) {\n                    var fn;\n                    if (obj != null) fn = obj[methodName];\n                    if (typeof fn !== \"function\") {\n                        var message = \"Object \" + util.classString(obj) + \" has no method '\" + util.toString(methodName) + \"'\";\n                        throw new Promise.TypeError(message);\n                    }\n                    return fn;\n                }\n\n                function caller(obj) {\n                    var methodName = this.pop();\n                    var fn = ensureMethod(obj, methodName);\n                    return fn.apply(obj, this);\n                }\n                Promise.prototype.call = function (methodName) {\n                    var args = [].slice.call(arguments, 1);;\n                    if (false) { var maybeCaller; }\n                    args.push(methodName);\n                    return this._then(caller, undefined, undefined, args, undefined);\n                };\n\n                function namedGetter(obj) {\n                    return obj[this];\n                }\n                function indexedGetter(obj) {\n                    var index = +this;\n                    if (index < 0) index = Math.max(0, index + obj.length);\n                    return obj[index];\n                }\n                Promise.prototype.get = function (propertyName) {\n                    var isIndex = typeof propertyName === \"number\";\n                    var getter;\n                    if (!isIndex) {\n                        if (canEvaluate) {\n                            var maybeGetter = getGetter(propertyName);\n                            getter = maybeGetter !== null ? maybeGetter : namedGetter;\n                        } else {\n                            getter = namedGetter;\n                        }\n                    } else {\n                        getter = indexedGetter;\n                    }\n                    return this._then(getter, undefined, undefined, propertyName, undefined);\n                };\n            };\n        }, { \"./util\": 36 }], 6: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, PromiseArray, apiRejection, debug) {\n                var util = _dereq_(\"./util\");\n                var tryCatch = util.tryCatch;\n                var errorObj = util.errorObj;\n                var async = Promise._async;\n\n                Promise.prototype[\"break\"] = Promise.prototype.cancel = function () {\n                    if (!debug.cancellation()) return this._warn(\"cancellation is disabled\");\n\n                    var promise = this;\n                    var child = promise;\n                    while (promise._isCancellable()) {\n                        if (!promise._cancelBy(child)) {\n                            if (child._isFollowing()) {\n                                child._followee().cancel();\n                            } else {\n                                child._cancelBranched();\n                            }\n                            break;\n                        }\n\n                        var parent = promise._cancellationParent;\n                        if (parent == null || !parent._isCancellable()) {\n                            if (promise._isFollowing()) {\n                                promise._followee().cancel();\n                            } else {\n                                promise._cancelBranched();\n                            }\n                            break;\n                        } else {\n                            if (promise._isFollowing()) promise._followee().cancel();\n                            promise._setWillBeCancelled();\n                            child = promise;\n                            promise = parent;\n                        }\n                    }\n                };\n\n                Promise.prototype._branchHasCancelled = function () {\n                    this._branchesRemainingToCancel--;\n                };\n\n                Promise.prototype._enoughBranchesHaveCancelled = function () {\n                    return this._branchesRemainingToCancel === undefined || this._branchesRemainingToCancel <= 0;\n                };\n\n                Promise.prototype._cancelBy = function (canceller) {\n                    if (canceller === this) {\n                        this._branchesRemainingToCancel = 0;\n                        this._invokeOnCancel();\n                        return true;\n                    } else {\n                        this._branchHasCancelled();\n                        if (this._enoughBranchesHaveCancelled()) {\n                            this._invokeOnCancel();\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n\n                Promise.prototype._cancelBranched = function () {\n                    if (this._enoughBranchesHaveCancelled()) {\n                        this._cancel();\n                    }\n                };\n\n                Promise.prototype._cancel = function () {\n                    if (!this._isCancellable()) return;\n                    this._setCancelled();\n                    async.invoke(this._cancelPromises, this, undefined);\n                };\n\n                Promise.prototype._cancelPromises = function () {\n                    if (this._length() > 0) this._settlePromises();\n                };\n\n                Promise.prototype._unsetOnCancel = function () {\n                    this._onCancelField = undefined;\n                };\n\n                Promise.prototype._isCancellable = function () {\n                    return this.isPending() && !this._isCancelled();\n                };\n\n                Promise.prototype.isCancellable = function () {\n                    return this.isPending() && !this.isCancelled();\n                };\n\n                Promise.prototype._doInvokeOnCancel = function (onCancelCallback, internalOnly) {\n                    if (util.isArray(onCancelCallback)) {\n                        for (var i = 0; i < onCancelCallback.length; ++i) {\n                            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);\n                        }\n                    } else if (onCancelCallback !== undefined) {\n                        if (typeof onCancelCallback === \"function\") {\n                            if (!internalOnly) {\n                                var e = tryCatch(onCancelCallback).call(this._boundValue());\n                                if (e === errorObj) {\n                                    this._attachExtraTrace(e.e);\n                                    async.throwLater(e.e);\n                                }\n                            }\n                        } else {\n                            onCancelCallback._resultCancelled(this);\n                        }\n                    }\n                };\n\n                Promise.prototype._invokeOnCancel = function () {\n                    var onCancelCallback = this._onCancel();\n                    this._unsetOnCancel();\n                    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);\n                };\n\n                Promise.prototype._invokeInternalOnCancel = function () {\n                    if (this._isCancellable()) {\n                        this._doInvokeOnCancel(this._onCancel(), true);\n                        this._unsetOnCancel();\n                    }\n                };\n\n                Promise.prototype._resultCancelled = function () {\n                    this.cancel();\n                };\n            };\n        }, { \"./util\": 36 }], 7: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (NEXT_FILTER) {\n                var util = _dereq_(\"./util\");\n                var getKeys = _dereq_(\"./es5\").keys;\n                var tryCatch = util.tryCatch;\n                var errorObj = util.errorObj;\n\n                function catchFilter(instances, cb, promise) {\n                    return function (e) {\n                        var boundTo = promise._boundValue();\n                        predicateLoop: for (var i = 0; i < instances.length; ++i) {\n                            var item = instances[i];\n\n                            if (item === Error || item != null && item.prototype instanceof Error) {\n                                if (e instanceof item) {\n                                    return tryCatch(cb).call(boundTo, e);\n                                }\n                            } else if (typeof item === \"function\") {\n                                var matchesPredicate = tryCatch(item).call(boundTo, e);\n                                if (matchesPredicate === errorObj) {\n                                    return matchesPredicate;\n                                } else if (matchesPredicate) {\n                                    return tryCatch(cb).call(boundTo, e);\n                                }\n                            } else if (util.isObject(e)) {\n                                var keys = getKeys(item);\n                                for (var j = 0; j < keys.length; ++j) {\n                                    var key = keys[j];\n                                    if (item[key] != e[key]) {\n                                        continue predicateLoop;\n                                    }\n                                }\n                                return tryCatch(cb).call(boundTo, e);\n                            }\n                        }\n                        return NEXT_FILTER;\n                    };\n                }\n\n                return catchFilter;\n            };\n        }, { \"./es5\": 13, \"./util\": 36 }], 8: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise) {\n                var longStackTraces = false;\n                var contextStack = [];\n\n                Promise.prototype._promiseCreated = function () {};\n                Promise.prototype._pushContext = function () {};\n                Promise.prototype._popContext = function () {\n                    return null;\n                };\n                Promise._peekContext = Promise.prototype._peekContext = function () {};\n\n                function Context() {\n                    this._trace = new Context.CapturedTrace(peekContext());\n                }\n                Context.prototype._pushContext = function () {\n                    if (this._trace !== undefined) {\n                        this._trace._promiseCreated = null;\n                        contextStack.push(this._trace);\n                    }\n                };\n\n                Context.prototype._popContext = function () {\n                    if (this._trace !== undefined) {\n                        var trace = contextStack.pop();\n                        var ret = trace._promiseCreated;\n                        trace._promiseCreated = null;\n                        return ret;\n                    }\n                    return null;\n                };\n\n                function createContext() {\n                    if (longStackTraces) return new Context();\n                }\n\n                function peekContext() {\n                    var lastIndex = contextStack.length - 1;\n                    if (lastIndex >= 0) {\n                        return contextStack[lastIndex];\n                    }\n                    return undefined;\n                }\n                Context.CapturedTrace = null;\n                Context.create = createContext;\n                Context.deactivateLongStackTraces = function () {};\n                Context.activateLongStackTraces = function () {\n                    var Promise_pushContext = Promise.prototype._pushContext;\n                    var Promise_popContext = Promise.prototype._popContext;\n                    var Promise_PeekContext = Promise._peekContext;\n                    var Promise_peekContext = Promise.prototype._peekContext;\n                    var Promise_promiseCreated = Promise.prototype._promiseCreated;\n                    Context.deactivateLongStackTraces = function () {\n                        Promise.prototype._pushContext = Promise_pushContext;\n                        Promise.prototype._popContext = Promise_popContext;\n                        Promise._peekContext = Promise_PeekContext;\n                        Promise.prototype._peekContext = Promise_peekContext;\n                        Promise.prototype._promiseCreated = Promise_promiseCreated;\n                        longStackTraces = false;\n                    };\n                    longStackTraces = true;\n                    Promise.prototype._pushContext = Context.prototype._pushContext;\n                    Promise.prototype._popContext = Context.prototype._popContext;\n                    Promise._peekContext = Promise.prototype._peekContext = peekContext;\n                    Promise.prototype._promiseCreated = function () {\n                        var ctx = this._peekContext();\n                        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;\n                    };\n                };\n                return Context;\n            };\n        }, {}], 9: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, Context) {\n                var getDomain = Promise._getDomain;\n                var async = Promise._async;\n                var Warning = _dereq_(\"./errors\").Warning;\n                var util = _dereq_(\"./util\");\n                var canAttachTrace = util.canAttachTrace;\n                var unhandledRejectionHandled;\n                var possiblyUnhandledRejection;\n                var bluebirdFramePattern = /[\\\\\\/]bluebird[\\\\\\/]js[\\\\\\/](release|debug|instrumented)/;\n                var nodeFramePattern = /\\((?:timers\\.js):\\d+:\\d+\\)/;\n                var parseLinePattern = /[\\/<\\(](.+?):(\\d+):(\\d+)\\)?\\s*$/;\n                var stackFramePattern = null;\n                var formatStack = null;\n                var indentStackFrames = false;\n                var printWarning;\n                var debugging = !!(util.env(\"BLUEBIRD_DEBUG\") != 0 && (true || util.env(\"BLUEBIRD_DEBUG\") || util.env(\"NODE_ENV\") === \"development\"));\n\n                var warnings = !!(util.env(\"BLUEBIRD_WARNINGS\") != 0 && (debugging || util.env(\"BLUEBIRD_WARNINGS\")));\n\n                var longStackTraces = !!(util.env(\"BLUEBIRD_LONG_STACK_TRACES\") != 0 && (debugging || util.env(\"BLUEBIRD_LONG_STACK_TRACES\")));\n\n                var wForgottenReturn = util.env(\"BLUEBIRD_W_FORGOTTEN_RETURN\") != 0 && (warnings || !!util.env(\"BLUEBIRD_W_FORGOTTEN_RETURN\"));\n\n                Promise.prototype.suppressUnhandledRejections = function () {\n                    var target = this._target();\n                    target._bitField = target._bitField & ~1048576 | 524288;\n                };\n\n                Promise.prototype._ensurePossibleRejectionHandled = function () {\n                    if ((this._bitField & 524288) !== 0) return;\n                    this._setRejectionIsUnhandled();\n                    var self = this;\n                    setTimeout(function () {\n                        self._notifyUnhandledRejection();\n                    }, 1);\n                };\n\n                Promise.prototype._notifyUnhandledRejectionIsHandled = function () {\n                    fireRejectionEvent(\"rejectionHandled\", unhandledRejectionHandled, undefined, this);\n                };\n\n                Promise.prototype._setReturnedNonUndefined = function () {\n                    this._bitField = this._bitField | 268435456;\n                };\n\n                Promise.prototype._returnedNonUndefined = function () {\n                    return (this._bitField & 268435456) !== 0;\n                };\n\n                Promise.prototype._notifyUnhandledRejection = function () {\n                    if (this._isRejectionUnhandled()) {\n                        var reason = this._settledValue();\n                        this._setUnhandledRejectionIsNotified();\n                        fireRejectionEvent(\"unhandledRejection\", possiblyUnhandledRejection, reason, this);\n                    }\n                };\n\n                Promise.prototype._setUnhandledRejectionIsNotified = function () {\n                    this._bitField = this._bitField | 262144;\n                };\n\n                Promise.prototype._unsetUnhandledRejectionIsNotified = function () {\n                    this._bitField = this._bitField & ~262144;\n                };\n\n                Promise.prototype._isUnhandledRejectionNotified = function () {\n                    return (this._bitField & 262144) > 0;\n                };\n\n                Promise.prototype._setRejectionIsUnhandled = function () {\n                    this._bitField = this._bitField | 1048576;\n                };\n\n                Promise.prototype._unsetRejectionIsUnhandled = function () {\n                    this._bitField = this._bitField & ~1048576;\n                    if (this._isUnhandledRejectionNotified()) {\n                        this._unsetUnhandledRejectionIsNotified();\n                        this._notifyUnhandledRejectionIsHandled();\n                    }\n                };\n\n                Promise.prototype._isRejectionUnhandled = function () {\n                    return (this._bitField & 1048576) > 0;\n                };\n\n                Promise.prototype._warn = function (message, shouldUseOwnTrace, promise) {\n                    return warn(message, shouldUseOwnTrace, promise || this);\n                };\n\n                Promise.onPossiblyUnhandledRejection = function (fn) {\n                    var domain = getDomain();\n                    possiblyUnhandledRejection = typeof fn === \"function\" ? domain === null ? fn : util.domainBind(domain, fn) : undefined;\n                };\n\n                Promise.onUnhandledRejectionHandled = function (fn) {\n                    var domain = getDomain();\n                    unhandledRejectionHandled = typeof fn === \"function\" ? domain === null ? fn : util.domainBind(domain, fn) : undefined;\n                };\n\n                var disableLongStackTraces = function () {};\n                Promise.longStackTraces = function () {\n                    if (async.haveItemsQueued() && !config.longStackTraces) {\n                        throw new Error(\"cannot enable long stack traces after promises have been created\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n                    }\n                    if (!config.longStackTraces && longStackTracesIsSupported()) {\n                        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;\n                        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;\n                        config.longStackTraces = true;\n                        disableLongStackTraces = function () {\n                            if (async.haveItemsQueued() && !config.longStackTraces) {\n                                throw new Error(\"cannot enable long stack traces after promises have been created\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n                            }\n                            Promise.prototype._captureStackTrace = Promise_captureStackTrace;\n                            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;\n                            Context.deactivateLongStackTraces();\n                            async.enableTrampoline();\n                            config.longStackTraces = false;\n                        };\n                        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;\n                        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;\n                        Context.activateLongStackTraces();\n                        async.disableTrampolineIfNecessary();\n                    }\n                };\n\n                Promise.hasLongStackTraces = function () {\n                    return config.longStackTraces && longStackTracesIsSupported();\n                };\n\n                var fireDomEvent = function () {\n                    try {\n                        if (typeof CustomEvent === \"function\") {\n                            var event = new CustomEvent(\"CustomEvent\");\n                            util.global.dispatchEvent(event);\n                            return function (name, event) {\n                                var domEvent = new CustomEvent(name.toLowerCase(), {\n                                    detail: event,\n                                    cancelable: true\n                                });\n                                return !util.global.dispatchEvent(domEvent);\n                            };\n                        } else if (typeof Event === \"function\") {\n                            var event = new Event(\"CustomEvent\");\n                            util.global.dispatchEvent(event);\n                            return function (name, event) {\n                                var domEvent = new Event(name.toLowerCase(), {\n                                    cancelable: true\n                                });\n                                domEvent.detail = event;\n                                return !util.global.dispatchEvent(domEvent);\n                            };\n                        } else {\n                            var event = document.createEvent(\"CustomEvent\");\n                            event.initCustomEvent(\"testingtheevent\", false, true, {});\n                            util.global.dispatchEvent(event);\n                            return function (name, event) {\n                                var domEvent = document.createEvent(\"CustomEvent\");\n                                domEvent.initCustomEvent(name.toLowerCase(), false, true, event);\n                                return !util.global.dispatchEvent(domEvent);\n                            };\n                        }\n                    } catch (e) {}\n                    return function () {\n                        return false;\n                    };\n                }();\n\n                var fireGlobalEvent = function () {\n                    if (util.isNode) {\n                        return function () {\n                            return process.emit.apply(process, arguments);\n                        };\n                    } else {\n                        if (!util.global) {\n                            return function () {\n                                return false;\n                            };\n                        }\n                        return function (name) {\n                            var methodName = \"on\" + name.toLowerCase();\n                            var method = util.global[methodName];\n                            if (!method) return false;\n                            method.apply(util.global, [].slice.call(arguments, 1));\n                            return true;\n                        };\n                    }\n                }();\n\n                function generatePromiseLifecycleEventObject(name, promise) {\n                    return { promise: promise };\n                }\n\n                var eventToObjectGenerator = {\n                    promiseCreated: generatePromiseLifecycleEventObject,\n                    promiseFulfilled: generatePromiseLifecycleEventObject,\n                    promiseRejected: generatePromiseLifecycleEventObject,\n                    promiseResolved: generatePromiseLifecycleEventObject,\n                    promiseCancelled: generatePromiseLifecycleEventObject,\n                    promiseChained: function (name, promise, child) {\n                        return { promise: promise, child: child };\n                    },\n                    warning: function (name, warning) {\n                        return { warning: warning };\n                    },\n                    unhandledRejection: function (name, reason, promise) {\n                        return { reason: reason, promise: promise };\n                    },\n                    rejectionHandled: generatePromiseLifecycleEventObject\n                };\n\n                var activeFireEvent = function (name) {\n                    var globalEventFired = false;\n                    try {\n                        globalEventFired = fireGlobalEvent.apply(null, arguments);\n                    } catch (e) {\n                        async.throwLater(e);\n                        globalEventFired = true;\n                    }\n\n                    var domEventFired = false;\n                    try {\n                        domEventFired = fireDomEvent(name, eventToObjectGenerator[name].apply(null, arguments));\n                    } catch (e) {\n                        async.throwLater(e);\n                        domEventFired = true;\n                    }\n\n                    return domEventFired || globalEventFired;\n                };\n\n                Promise.config = function (opts) {\n                    opts = Object(opts);\n                    if (\"longStackTraces\" in opts) {\n                        if (opts.longStackTraces) {\n                            Promise.longStackTraces();\n                        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {\n                            disableLongStackTraces();\n                        }\n                    }\n                    if (\"warnings\" in opts) {\n                        var warningsOption = opts.warnings;\n                        config.warnings = !!warningsOption;\n                        wForgottenReturn = config.warnings;\n\n                        if (util.isObject(warningsOption)) {\n                            if (\"wForgottenReturn\" in warningsOption) {\n                                wForgottenReturn = !!warningsOption.wForgottenReturn;\n                            }\n                        }\n                    }\n                    if (\"cancellation\" in opts && opts.cancellation && !config.cancellation) {\n                        if (async.haveItemsQueued()) {\n                            throw new Error(\"cannot enable cancellation after promises are in use\");\n                        }\n                        Promise.prototype._clearCancellationData = cancellationClearCancellationData;\n                        Promise.prototype._propagateFrom = cancellationPropagateFrom;\n                        Promise.prototype._onCancel = cancellationOnCancel;\n                        Promise.prototype._setOnCancel = cancellationSetOnCancel;\n                        Promise.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;\n                        Promise.prototype._execute = cancellationExecute;\n                        propagateFromFunction = cancellationPropagateFrom;\n                        config.cancellation = true;\n                    }\n                    if (\"monitoring\" in opts) {\n                        if (opts.monitoring && !config.monitoring) {\n                            config.monitoring = true;\n                            Promise.prototype._fireEvent = activeFireEvent;\n                        } else if (!opts.monitoring && config.monitoring) {\n                            config.monitoring = false;\n                            Promise.prototype._fireEvent = defaultFireEvent;\n                        }\n                    }\n                    return Promise;\n                };\n\n                function defaultFireEvent() {\n                    return false;\n                }\n\n                Promise.prototype._fireEvent = defaultFireEvent;\n                Promise.prototype._execute = function (executor, resolve, reject) {\n                    try {\n                        executor(resolve, reject);\n                    } catch (e) {\n                        return e;\n                    }\n                };\n                Promise.prototype._onCancel = function () {};\n                Promise.prototype._setOnCancel = function (handler) {\n                    ;\n                };\n                Promise.prototype._attachCancellationCallback = function (onCancel) {\n                    ;\n                };\n                Promise.prototype._captureStackTrace = function () {};\n                Promise.prototype._attachExtraTrace = function () {};\n                Promise.prototype._clearCancellationData = function () {};\n                Promise.prototype._propagateFrom = function (parent, flags) {\n                    ;\n                    ;\n                };\n\n                function cancellationExecute(executor, resolve, reject) {\n                    var promise = this;\n                    try {\n                        executor(resolve, reject, function (onCancel) {\n                            if (typeof onCancel !== \"function\") {\n                                throw new TypeError(\"onCancel must be a function, got: \" + util.toString(onCancel));\n                            }\n                            promise._attachCancellationCallback(onCancel);\n                        });\n                    } catch (e) {\n                        return e;\n                    }\n                }\n\n                function cancellationAttachCancellationCallback(onCancel) {\n                    if (!this._isCancellable()) return this;\n\n                    var previousOnCancel = this._onCancel();\n                    if (previousOnCancel !== undefined) {\n                        if (util.isArray(previousOnCancel)) {\n                            previousOnCancel.push(onCancel);\n                        } else {\n                            this._setOnCancel([previousOnCancel, onCancel]);\n                        }\n                    } else {\n                        this._setOnCancel(onCancel);\n                    }\n                }\n\n                function cancellationOnCancel() {\n                    return this._onCancelField;\n                }\n\n                function cancellationSetOnCancel(onCancel) {\n                    this._onCancelField = onCancel;\n                }\n\n                function cancellationClearCancellationData() {\n                    this._cancellationParent = undefined;\n                    this._onCancelField = undefined;\n                }\n\n                function cancellationPropagateFrom(parent, flags) {\n                    if ((flags & 1) !== 0) {\n                        this._cancellationParent = parent;\n                        var branchesRemainingToCancel = parent._branchesRemainingToCancel;\n                        if (branchesRemainingToCancel === undefined) {\n                            branchesRemainingToCancel = 0;\n                        }\n                        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;\n                    }\n                    if ((flags & 2) !== 0 && parent._isBound()) {\n                        this._setBoundTo(parent._boundTo);\n                    }\n                }\n\n                function bindingPropagateFrom(parent, flags) {\n                    if ((flags & 2) !== 0 && parent._isBound()) {\n                        this._setBoundTo(parent._boundTo);\n                    }\n                }\n                var propagateFromFunction = bindingPropagateFrom;\n\n                function boundValueFunction() {\n                    var ret = this._boundTo;\n                    if (ret !== undefined) {\n                        if (ret instanceof Promise) {\n                            if (ret.isFulfilled()) {\n                                return ret.value();\n                            } else {\n                                return undefined;\n                            }\n                        }\n                    }\n                    return ret;\n                }\n\n                function longStackTracesCaptureStackTrace() {\n                    this._trace = new CapturedTrace(this._peekContext());\n                }\n\n                function longStackTracesAttachExtraTrace(error, ignoreSelf) {\n                    if (canAttachTrace(error)) {\n                        var trace = this._trace;\n                        if (trace !== undefined) {\n                            if (ignoreSelf) trace = trace._parent;\n                        }\n                        if (trace !== undefined) {\n                            trace.attachExtraTrace(error);\n                        } else if (!error.__stackCleaned__) {\n                            var parsed = parseStackAndMessage(error);\n                            util.notEnumerableProp(error, \"stack\", parsed.message + \"\\n\" + parsed.stack.join(\"\\n\"));\n                            util.notEnumerableProp(error, \"__stackCleaned__\", true);\n                        }\n                    }\n                }\n\n                function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {\n                    if (returnValue === undefined && promiseCreated !== null && wForgottenReturn) {\n                        if (parent !== undefined && parent._returnedNonUndefined()) return;\n                        if ((promise._bitField & 65535) === 0) return;\n\n                        if (name) name = name + \" \";\n                        var handlerLine = \"\";\n                        var creatorLine = \"\";\n                        if (promiseCreated._trace) {\n                            var traceLines = promiseCreated._trace.stack.split(\"\\n\");\n                            var stack = cleanStack(traceLines);\n                            for (var i = stack.length - 1; i >= 0; --i) {\n                                var line = stack[i];\n                                if (!nodeFramePattern.test(line)) {\n                                    var lineMatches = line.match(parseLinePattern);\n                                    if (lineMatches) {\n                                        handlerLine = \"at \" + lineMatches[1] + \":\" + lineMatches[2] + \":\" + lineMatches[3] + \" \";\n                                    }\n                                    break;\n                                }\n                            }\n\n                            if (stack.length > 0) {\n                                var firstUserLine = stack[0];\n                                for (var i = 0; i < traceLines.length; ++i) {\n\n                                    if (traceLines[i] === firstUserLine) {\n                                        if (i > 0) {\n                                            creatorLine = \"\\n\" + traceLines[i - 1];\n                                        }\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                        var msg = \"a promise was created in a \" + name + \"handler \" + handlerLine + \"but was not returned from it, \" + \"see http://goo.gl/rRqMUw\" + creatorLine;\n                        promise._warn(msg, true, promiseCreated);\n                    }\n                }\n\n                function deprecated(name, replacement) {\n                    var message = name + \" is deprecated and will be removed in a future version.\";\n                    if (replacement) message += \" Use \" + replacement + \" instead.\";\n                    return warn(message);\n                }\n\n                function warn(message, shouldUseOwnTrace, promise) {\n                    if (!config.warnings) return;\n                    var warning = new Warning(message);\n                    var ctx;\n                    if (shouldUseOwnTrace) {\n                        promise._attachExtraTrace(warning);\n                    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {\n                        ctx.attachExtraTrace(warning);\n                    } else {\n                        var parsed = parseStackAndMessage(warning);\n                        warning.stack = parsed.message + \"\\n\" + parsed.stack.join(\"\\n\");\n                    }\n\n                    if (!activeFireEvent(\"warning\", warning)) {\n                        formatAndLogError(warning, \"\", true);\n                    }\n                }\n\n                function reconstructStack(message, stacks) {\n                    for (var i = 0; i < stacks.length - 1; ++i) {\n                        stacks[i].push(\"From previous event:\");\n                        stacks[i] = stacks[i].join(\"\\n\");\n                    }\n                    if (i < stacks.length) {\n                        stacks[i] = stacks[i].join(\"\\n\");\n                    }\n                    return message + \"\\n\" + stacks.join(\"\\n\");\n                }\n\n                function removeDuplicateOrEmptyJumps(stacks) {\n                    for (var i = 0; i < stacks.length; ++i) {\n                        if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {\n                            stacks.splice(i, 1);\n                            i--;\n                        }\n                    }\n                }\n\n                function removeCommonRoots(stacks) {\n                    var current = stacks[0];\n                    for (var i = 1; i < stacks.length; ++i) {\n                        var prev = stacks[i];\n                        var currentLastIndex = current.length - 1;\n                        var currentLastLine = current[currentLastIndex];\n                        var commonRootMeetPoint = -1;\n\n                        for (var j = prev.length - 1; j >= 0; --j) {\n                            if (prev[j] === currentLastLine) {\n                                commonRootMeetPoint = j;\n                                break;\n                            }\n                        }\n\n                        for (var j = commonRootMeetPoint; j >= 0; --j) {\n                            var line = prev[j];\n                            if (current[currentLastIndex] === line) {\n                                current.pop();\n                                currentLastIndex--;\n                            } else {\n                                break;\n                            }\n                        }\n                        current = prev;\n                    }\n                }\n\n                function cleanStack(stack) {\n                    var ret = [];\n                    for (var i = 0; i < stack.length; ++i) {\n                        var line = stack[i];\n                        var isTraceLine = \"    (No stack trace)\" === line || stackFramePattern.test(line);\n                        var isInternalFrame = isTraceLine && shouldIgnore(line);\n                        if (isTraceLine && !isInternalFrame) {\n                            if (indentStackFrames && line.charAt(0) !== \" \") {\n                                line = \"    \" + line;\n                            }\n                            ret.push(line);\n                        }\n                    }\n                    return ret;\n                }\n\n                function stackFramesAsArray(error) {\n                    var stack = error.stack.replace(/\\s+$/g, \"\").split(\"\\n\");\n                    for (var i = 0; i < stack.length; ++i) {\n                        var line = stack[i];\n                        if (\"    (No stack trace)\" === line || stackFramePattern.test(line)) {\n                            break;\n                        }\n                    }\n                    if (i > 0 && error.name != \"SyntaxError\") {\n                        stack = stack.slice(i);\n                    }\n                    return stack;\n                }\n\n                function parseStackAndMessage(error) {\n                    var stack = error.stack;\n                    var message = error.toString();\n                    stack = typeof stack === \"string\" && stack.length > 0 ? stackFramesAsArray(error) : [\"    (No stack trace)\"];\n                    return {\n                        message: message,\n                        stack: error.name == \"SyntaxError\" ? stack : cleanStack(stack)\n                    };\n                }\n\n                function formatAndLogError(error, title, isSoft) {\n                    if (typeof console !== \"undefined\") {\n                        var message;\n                        if (util.isObject(error)) {\n                            var stack = error.stack;\n                            message = title + formatStack(stack, error);\n                        } else {\n                            message = title + String(error);\n                        }\n                        if (typeof printWarning === \"function\") {\n                            printWarning(message, isSoft);\n                        } else if (typeof console.log === \"function\" || typeof console.log === \"object\") {\n                            console.log(message);\n                        }\n                    }\n                }\n\n                function fireRejectionEvent(name, localHandler, reason, promise) {\n                    var localEventFired = false;\n                    try {\n                        if (typeof localHandler === \"function\") {\n                            localEventFired = true;\n                            if (name === \"rejectionHandled\") {\n                                localHandler(promise);\n                            } else {\n                                localHandler(reason, promise);\n                            }\n                        }\n                    } catch (e) {\n                        async.throwLater(e);\n                    }\n\n                    if (name === \"unhandledRejection\") {\n                        if (!activeFireEvent(name, reason, promise) && !localEventFired) {\n                            formatAndLogError(reason, \"Unhandled rejection \");\n                        }\n                    } else {\n                        activeFireEvent(name, promise);\n                    }\n                }\n\n                function formatNonError(obj) {\n                    var str;\n                    if (typeof obj === \"function\") {\n                        str = \"[function \" + (obj.name || \"anonymous\") + \"]\";\n                    } else {\n                        str = obj && typeof obj.toString === \"function\" ? obj.toString() : util.toString(obj);\n                        var ruselessToString = /\\[object [a-zA-Z0-9$_]+\\]/;\n                        if (ruselessToString.test(str)) {\n                            try {\n                                var newStr = JSON.stringify(obj);\n                                str = newStr;\n                            } catch (e) {}\n                        }\n                        if (str.length === 0) {\n                            str = \"(empty array)\";\n                        }\n                    }\n                    return \"(<\" + snip(str) + \">, no stack trace)\";\n                }\n\n                function snip(str) {\n                    var maxChars = 41;\n                    if (str.length < maxChars) {\n                        return str;\n                    }\n                    return str.substr(0, maxChars - 3) + \"...\";\n                }\n\n                function longStackTracesIsSupported() {\n                    return typeof captureStackTrace === \"function\";\n                }\n\n                var shouldIgnore = function () {\n                    return false;\n                };\n                var parseLineInfoRegex = /[\\/<\\(]([^:\\/]+):(\\d+):(?:\\d+)\\)?\\s*$/;\n                function parseLineInfo(line) {\n                    var matches = line.match(parseLineInfoRegex);\n                    if (matches) {\n                        return {\n                            fileName: matches[1],\n                            line: parseInt(matches[2], 10)\n                        };\n                    }\n                }\n\n                function setBounds(firstLineError, lastLineError) {\n                    if (!longStackTracesIsSupported()) return;\n                    var firstStackLines = firstLineError.stack.split(\"\\n\");\n                    var lastStackLines = lastLineError.stack.split(\"\\n\");\n                    var firstIndex = -1;\n                    var lastIndex = -1;\n                    var firstFileName;\n                    var lastFileName;\n                    for (var i = 0; i < firstStackLines.length; ++i) {\n                        var result = parseLineInfo(firstStackLines[i]);\n                        if (result) {\n                            firstFileName = result.fileName;\n                            firstIndex = result.line;\n                            break;\n                        }\n                    }\n                    for (var i = 0; i < lastStackLines.length; ++i) {\n                        var result = parseLineInfo(lastStackLines[i]);\n                        if (result) {\n                            lastFileName = result.fileName;\n                            lastIndex = result.line;\n                            break;\n                        }\n                    }\n                    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {\n                        return;\n                    }\n\n                    shouldIgnore = function (line) {\n                        if (bluebirdFramePattern.test(line)) return true;\n                        var info = parseLineInfo(line);\n                        if (info) {\n                            if (info.fileName === firstFileName && firstIndex <= info.line && info.line <= lastIndex) {\n                                return true;\n                            }\n                        }\n                        return false;\n                    };\n                }\n\n                function CapturedTrace(parent) {\n                    this._parent = parent;\n                    this._promisesCreated = 0;\n                    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);\n                    captureStackTrace(this, CapturedTrace);\n                    if (length > 32) this.uncycle();\n                }\n                util.inherits(CapturedTrace, Error);\n                Context.CapturedTrace = CapturedTrace;\n\n                CapturedTrace.prototype.uncycle = function () {\n                    var length = this._length;\n                    if (length < 2) return;\n                    var nodes = [];\n                    var stackToIndex = {};\n\n                    for (var i = 0, node = this; node !== undefined; ++i) {\n                        nodes.push(node);\n                        node = node._parent;\n                    }\n                    length = this._length = i;\n                    for (var i = length - 1; i >= 0; --i) {\n                        var stack = nodes[i].stack;\n                        if (stackToIndex[stack] === undefined) {\n                            stackToIndex[stack] = i;\n                        }\n                    }\n                    for (var i = 0; i < length; ++i) {\n                        var currentStack = nodes[i].stack;\n                        var index = stackToIndex[currentStack];\n                        if (index !== undefined && index !== i) {\n                            if (index > 0) {\n                                nodes[index - 1]._parent = undefined;\n                                nodes[index - 1]._length = 1;\n                            }\n                            nodes[i]._parent = undefined;\n                            nodes[i]._length = 1;\n                            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;\n\n                            if (index < length - 1) {\n                                cycleEdgeNode._parent = nodes[index + 1];\n                                cycleEdgeNode._parent.uncycle();\n                                cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;\n                            } else {\n                                cycleEdgeNode._parent = undefined;\n                                cycleEdgeNode._length = 1;\n                            }\n                            var currentChildLength = cycleEdgeNode._length + 1;\n                            for (var j = i - 2; j >= 0; --j) {\n                                nodes[j]._length = currentChildLength;\n                                currentChildLength++;\n                            }\n                            return;\n                        }\n                    }\n                };\n\n                CapturedTrace.prototype.attachExtraTrace = function (error) {\n                    if (error.__stackCleaned__) return;\n                    this.uncycle();\n                    var parsed = parseStackAndMessage(error);\n                    var message = parsed.message;\n                    var stacks = [parsed.stack];\n\n                    var trace = this;\n                    while (trace !== undefined) {\n                        stacks.push(cleanStack(trace.stack.split(\"\\n\")));\n                        trace = trace._parent;\n                    }\n                    removeCommonRoots(stacks);\n                    removeDuplicateOrEmptyJumps(stacks);\n                    util.notEnumerableProp(error, \"stack\", reconstructStack(message, stacks));\n                    util.notEnumerableProp(error, \"__stackCleaned__\", true);\n                };\n\n                var captureStackTrace = function stackDetection() {\n                    var v8stackFramePattern = /^\\s*at\\s*/;\n                    var v8stackFormatter = function (stack, error) {\n                        if (typeof stack === \"string\") return stack;\n\n                        if (error.name !== undefined && error.message !== undefined) {\n                            return error.toString();\n                        }\n                        return formatNonError(error);\n                    };\n\n                    if (typeof Error.stackTraceLimit === \"number\" && typeof Error.captureStackTrace === \"function\") {\n                        Error.stackTraceLimit += 6;\n                        stackFramePattern = v8stackFramePattern;\n                        formatStack = v8stackFormatter;\n                        var captureStackTrace = Error.captureStackTrace;\n\n                        shouldIgnore = function (line) {\n                            return bluebirdFramePattern.test(line);\n                        };\n                        return function (receiver, ignoreUntil) {\n                            Error.stackTraceLimit += 6;\n                            captureStackTrace(receiver, ignoreUntil);\n                            Error.stackTraceLimit -= 6;\n                        };\n                    }\n                    var err = new Error();\n\n                    if (typeof err.stack === \"string\" && err.stack.split(\"\\n\")[0].indexOf(\"stackDetection@\") >= 0) {\n                        stackFramePattern = /@/;\n                        formatStack = v8stackFormatter;\n                        indentStackFrames = true;\n                        return function captureStackTrace(o) {\n                            o.stack = new Error().stack;\n                        };\n                    }\n\n                    var hasStackAfterThrow;\n                    try {\n                        throw new Error();\n                    } catch (e) {\n                        hasStackAfterThrow = \"stack\" in e;\n                    }\n                    if (!(\"stack\" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === \"number\") {\n                        stackFramePattern = v8stackFramePattern;\n                        formatStack = v8stackFormatter;\n                        return function captureStackTrace(o) {\n                            Error.stackTraceLimit += 6;\n                            try {\n                                throw new Error();\n                            } catch (e) {\n                                o.stack = e.stack;\n                            }\n                            Error.stackTraceLimit -= 6;\n                        };\n                    }\n\n                    formatStack = function (stack, error) {\n                        if (typeof stack === \"string\") return stack;\n\n                        if ((typeof error === \"object\" || typeof error === \"function\") && error.name !== undefined && error.message !== undefined) {\n                            return error.toString();\n                        }\n                        return formatNonError(error);\n                    };\n\n                    return null;\n                }([]);\n\n                if (typeof console !== \"undefined\" && typeof console.warn !== \"undefined\") {\n                    printWarning = function (message) {\n                        console.warn(message);\n                    };\n                    if (util.isNode && process.stderr.isTTY) {\n                        printWarning = function (message, isSoft) {\n                            var color = isSoft ? \"\\u001b[33m\" : \"\\u001b[31m\";\n                            console.warn(color + message + \"\\u001b[0m\\n\");\n                        };\n                    } else if (!util.isNode && typeof new Error().stack === \"string\") {\n                        printWarning = function (message, isSoft) {\n                            console.warn(\"%c\" + message, isSoft ? \"color: darkorange\" : \"color: red\");\n                        };\n                    }\n                }\n\n                var config = {\n                    warnings: warnings,\n                    longStackTraces: false,\n                    cancellation: false,\n                    monitoring: false\n                };\n\n                if (longStackTraces) Promise.longStackTraces();\n\n                return {\n                    longStackTraces: function () {\n                        return config.longStackTraces;\n                    },\n                    warnings: function () {\n                        return config.warnings;\n                    },\n                    cancellation: function () {\n                        return config.cancellation;\n                    },\n                    monitoring: function () {\n                        return config.monitoring;\n                    },\n                    propagateFromFunction: function () {\n                        return propagateFromFunction;\n                    },\n                    boundValueFunction: function () {\n                        return boundValueFunction;\n                    },\n                    checkForgottenReturns: checkForgottenReturns,\n                    setBounds: setBounds,\n                    warn: warn,\n                    deprecated: deprecated,\n                    CapturedTrace: CapturedTrace,\n                    fireDomEvent: fireDomEvent,\n                    fireGlobalEvent: fireGlobalEvent\n                };\n            };\n        }, { \"./errors\": 12, \"./util\": 36 }], 10: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise) {\n                function returner() {\n                    return this.value;\n                }\n                function thrower() {\n                    throw this.reason;\n                }\n\n                Promise.prototype[\"return\"] = Promise.prototype.thenReturn = function (value) {\n                    if (value instanceof Promise) value.suppressUnhandledRejections();\n                    return this._then(returner, undefined, undefined, { value: value }, undefined);\n                };\n\n                Promise.prototype[\"throw\"] = Promise.prototype.thenThrow = function (reason) {\n                    return this._then(thrower, undefined, undefined, { reason: reason }, undefined);\n                };\n\n                Promise.prototype.catchThrow = function (reason) {\n                    if (arguments.length <= 1) {\n                        return this._then(undefined, thrower, undefined, { reason: reason }, undefined);\n                    } else {\n                        var _reason = arguments[1];\n                        var handler = function () {\n                            throw _reason;\n                        };\n                        return this.caught(reason, handler);\n                    }\n                };\n\n                Promise.prototype.catchReturn = function (value) {\n                    if (arguments.length <= 1) {\n                        if (value instanceof Promise) value.suppressUnhandledRejections();\n                        return this._then(undefined, returner, undefined, { value: value }, undefined);\n                    } else {\n                        var _value = arguments[1];\n                        if (_value instanceof Promise) _value.suppressUnhandledRejections();\n                        var handler = function () {\n                            return _value;\n                        };\n                        return this.caught(value, handler);\n                    }\n                };\n            };\n        }, {}], 11: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, INTERNAL) {\n                var PromiseReduce = Promise.reduce;\n                var PromiseAll = Promise.all;\n\n                function promiseAllThis() {\n                    return PromiseAll(this);\n                }\n\n                function PromiseMapSeries(promises, fn) {\n                    return PromiseReduce(promises, fn, INTERNAL, INTERNAL);\n                }\n\n                Promise.prototype.each = function (fn) {\n                    return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, this, undefined);\n                };\n\n                Promise.prototype.mapSeries = function (fn) {\n                    return PromiseReduce(this, fn, INTERNAL, INTERNAL);\n                };\n\n                Promise.each = function (promises, fn) {\n                    return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, promises, undefined);\n                };\n\n                Promise.mapSeries = PromiseMapSeries;\n            };\n        }, {}], 12: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            var es5 = _dereq_(\"./es5\");\n            var Objectfreeze = es5.freeze;\n            var util = _dereq_(\"./util\");\n            var inherits = util.inherits;\n            var notEnumerableProp = util.notEnumerableProp;\n\n            function subError(nameProperty, defaultMessage) {\n                function SubError(message) {\n                    if (!(this instanceof SubError)) return new SubError(message);\n                    notEnumerableProp(this, \"message\", typeof message === \"string\" ? message : defaultMessage);\n                    notEnumerableProp(this, \"name\", nameProperty);\n                    if (Error.captureStackTrace) {\n                        Error.captureStackTrace(this, this.constructor);\n                    } else {\n                        Error.call(this);\n                    }\n                }\n                inherits(SubError, Error);\n                return SubError;\n            }\n\n            var _TypeError, _RangeError;\n            var Warning = subError(\"Warning\", \"warning\");\n            var CancellationError = subError(\"CancellationError\", \"cancellation error\");\n            var TimeoutError = subError(\"TimeoutError\", \"timeout error\");\n            var AggregateError = subError(\"AggregateError\", \"aggregate error\");\n            try {\n                _TypeError = TypeError;\n                _RangeError = RangeError;\n            } catch (e) {\n                _TypeError = subError(\"TypeError\", \"type error\");\n                _RangeError = subError(\"RangeError\", \"range error\");\n            }\n\n            var methods = (\"join pop push shift unshift slice filter forEach some \" + \"every map indexOf lastIndexOf reduce reduceRight sort reverse\").split(\" \");\n\n            for (var i = 0; i < methods.length; ++i) {\n                if (typeof Array.prototype[methods[i]] === \"function\") {\n                    AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];\n                }\n            }\n\n            es5.defineProperty(AggregateError.prototype, \"length\", {\n                value: 0,\n                configurable: false,\n                writable: true,\n                enumerable: true\n            });\n            AggregateError.prototype[\"isOperational\"] = true;\n            var level = 0;\n            AggregateError.prototype.toString = function () {\n                var indent = Array(level * 4 + 1).join(\" \");\n                var ret = \"\\n\" + indent + \"AggregateError of:\" + \"\\n\";\n                level++;\n                indent = Array(level * 4 + 1).join(\" \");\n                for (var i = 0; i < this.length; ++i) {\n                    var str = this[i] === this ? \"[Circular AggregateError]\" : this[i] + \"\";\n                    var lines = str.split(\"\\n\");\n                    for (var j = 0; j < lines.length; ++j) {\n                        lines[j] = indent + lines[j];\n                    }\n                    str = lines.join(\"\\n\");\n                    ret += str + \"\\n\";\n                }\n                level--;\n                return ret;\n            };\n\n            function OperationalError(message) {\n                if (!(this instanceof OperationalError)) return new OperationalError(message);\n                notEnumerableProp(this, \"name\", \"OperationalError\");\n                notEnumerableProp(this, \"message\", message);\n                this.cause = message;\n                this[\"isOperational\"] = true;\n\n                if (message instanceof Error) {\n                    notEnumerableProp(this, \"message\", message.message);\n                    notEnumerableProp(this, \"stack\", message.stack);\n                } else if (Error.captureStackTrace) {\n                    Error.captureStackTrace(this, this.constructor);\n                }\n            }\n            inherits(OperationalError, Error);\n\n            var errorTypes = Error[\"__BluebirdErrorTypes__\"];\n            if (!errorTypes) {\n                errorTypes = Objectfreeze({\n                    CancellationError: CancellationError,\n                    TimeoutError: TimeoutError,\n                    OperationalError: OperationalError,\n                    RejectionError: OperationalError,\n                    AggregateError: AggregateError\n                });\n                es5.defineProperty(Error, \"__BluebirdErrorTypes__\", {\n                    value: errorTypes,\n                    writable: false,\n                    enumerable: false,\n                    configurable: false\n                });\n            }\n\n            module.exports = {\n                Error: Error,\n                TypeError: _TypeError,\n                RangeError: _RangeError,\n                CancellationError: errorTypes.CancellationError,\n                OperationalError: errorTypes.OperationalError,\n                TimeoutError: errorTypes.TimeoutError,\n                AggregateError: errorTypes.AggregateError,\n                Warning: Warning\n            };\n        }, { \"./es5\": 13, \"./util\": 36 }], 13: [function (_dereq_, module, exports) {\n            var isES5 = function () {\n                \"use strict\";\n\n                return this === undefined;\n            }();\n\n            if (isES5) {\n                module.exports = {\n                    freeze: Object.freeze,\n                    defineProperty: Object.defineProperty,\n                    getDescriptor: Object.getOwnPropertyDescriptor,\n                    keys: Object.keys,\n                    names: Object.getOwnPropertyNames,\n                    getPrototypeOf: Object.getPrototypeOf,\n                    isArray: Array.isArray,\n                    isES5: isES5,\n                    propertyIsWritable: function (obj, prop) {\n                        var descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n                        return !!(!descriptor || descriptor.writable || descriptor.set);\n                    }\n                };\n            } else {\n                var has = {}.hasOwnProperty;\n                var str = {}.toString;\n                var proto = {}.constructor.prototype;\n\n                var ObjectKeys = function (o) {\n                    var ret = [];\n                    for (var key in o) {\n                        if (has.call(o, key)) {\n                            ret.push(key);\n                        }\n                    }\n                    return ret;\n                };\n\n                var ObjectGetDescriptor = function (o, key) {\n                    return { value: o[key] };\n                };\n\n                var ObjectDefineProperty = function (o, key, desc) {\n                    o[key] = desc.value;\n                    return o;\n                };\n\n                var ObjectFreeze = function (obj) {\n                    return obj;\n                };\n\n                var ObjectGetPrototypeOf = function (obj) {\n                    try {\n                        return Object(obj).constructor.prototype;\n                    } catch (e) {\n                        return proto;\n                    }\n                };\n\n                var ArrayIsArray = function (obj) {\n                    try {\n                        return str.call(obj) === \"[object Array]\";\n                    } catch (e) {\n                        return false;\n                    }\n                };\n\n                module.exports = {\n                    isArray: ArrayIsArray,\n                    keys: ObjectKeys,\n                    names: ObjectKeys,\n                    defineProperty: ObjectDefineProperty,\n                    getDescriptor: ObjectGetDescriptor,\n                    freeze: ObjectFreeze,\n                    getPrototypeOf: ObjectGetPrototypeOf,\n                    isES5: isES5,\n                    propertyIsWritable: function () {\n                        return true;\n                    }\n                };\n            }\n        }, {}], 14: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, INTERNAL) {\n                var PromiseMap = Promise.map;\n\n                Promise.prototype.filter = function (fn, options) {\n                    return PromiseMap(this, fn, options, INTERNAL);\n                };\n\n                Promise.filter = function (promises, fn, options) {\n                    return PromiseMap(promises, fn, options, INTERNAL);\n                };\n            };\n        }, {}], 15: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, tryConvertToPromise, NEXT_FILTER) {\n                var util = _dereq_(\"./util\");\n                var CancellationError = Promise.CancellationError;\n                var errorObj = util.errorObj;\n                var catchFilter = _dereq_(\"./catch_filter\")(NEXT_FILTER);\n\n                function PassThroughHandlerContext(promise, type, handler) {\n                    this.promise = promise;\n                    this.type = type;\n                    this.handler = handler;\n                    this.called = false;\n                    this.cancelPromise = null;\n                }\n\n                PassThroughHandlerContext.prototype.isFinallyHandler = function () {\n                    return this.type === 0;\n                };\n\n                function FinallyHandlerCancelReaction(finallyHandler) {\n                    this.finallyHandler = finallyHandler;\n                }\n\n                FinallyHandlerCancelReaction.prototype._resultCancelled = function () {\n                    checkCancel(this.finallyHandler);\n                };\n\n                function checkCancel(ctx, reason) {\n                    if (ctx.cancelPromise != null) {\n                        if (arguments.length > 1) {\n                            ctx.cancelPromise._reject(reason);\n                        } else {\n                            ctx.cancelPromise._cancel();\n                        }\n                        ctx.cancelPromise = null;\n                        return true;\n                    }\n                    return false;\n                }\n\n                function succeed() {\n                    return finallyHandler.call(this, this.promise._target()._settledValue());\n                }\n                function fail(reason) {\n                    if (checkCancel(this, reason)) return;\n                    errorObj.e = reason;\n                    return errorObj;\n                }\n                function finallyHandler(reasonOrValue) {\n                    var promise = this.promise;\n                    var handler = this.handler;\n\n                    if (!this.called) {\n                        this.called = true;\n                        var ret = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);\n                        if (ret === NEXT_FILTER) {\n                            return ret;\n                        } else if (ret !== undefined) {\n                            promise._setReturnedNonUndefined();\n                            var maybePromise = tryConvertToPromise(ret, promise);\n                            if (maybePromise instanceof Promise) {\n                                if (this.cancelPromise != null) {\n                                    if (maybePromise._isCancelled()) {\n                                        var reason = new CancellationError(\"late cancellation observer\");\n                                        promise._attachExtraTrace(reason);\n                                        errorObj.e = reason;\n                                        return errorObj;\n                                    } else if (maybePromise.isPending()) {\n                                        maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));\n                                    }\n                                }\n                                return maybePromise._then(succeed, fail, undefined, this, undefined);\n                            }\n                        }\n                    }\n\n                    if (promise.isRejected()) {\n                        checkCancel(this);\n                        errorObj.e = reasonOrValue;\n                        return errorObj;\n                    } else {\n                        checkCancel(this);\n                        return reasonOrValue;\n                    }\n                }\n\n                Promise.prototype._passThrough = function (handler, type, success, fail) {\n                    if (typeof handler !== \"function\") return this.then();\n                    return this._then(success, fail, undefined, new PassThroughHandlerContext(this, type, handler), undefined);\n                };\n\n                Promise.prototype.lastly = Promise.prototype[\"finally\"] = function (handler) {\n                    return this._passThrough(handler, 0, finallyHandler, finallyHandler);\n                };\n\n                Promise.prototype.tap = function (handler) {\n                    return this._passThrough(handler, 1, finallyHandler);\n                };\n\n                Promise.prototype.tapCatch = function (handlerOrPredicate) {\n                    var len = arguments.length;\n                    if (len === 1) {\n                        return this._passThrough(handlerOrPredicate, 1, undefined, finallyHandler);\n                    } else {\n                        var catchInstances = new Array(len - 1),\n                            j = 0,\n                            i;\n                        for (i = 0; i < len - 1; ++i) {\n                            var item = arguments[i];\n                            if (util.isObject(item)) {\n                                catchInstances[j++] = item;\n                            } else {\n                                return Promise.reject(new TypeError(\"tapCatch statement predicate: \" + \"expecting an object but got \" + util.classString(item)));\n                            }\n                        }\n                        catchInstances.length = j;\n                        var handler = arguments[i];\n                        return this._passThrough(catchFilter(catchInstances, handler, this), 1, undefined, finallyHandler);\n                    }\n                };\n\n                return PassThroughHandlerContext;\n            };\n        }, { \"./catch_filter\": 7, \"./util\": 36 }], 16: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {\n                var errors = _dereq_(\"./errors\");\n                var TypeError = errors.TypeError;\n                var util = _dereq_(\"./util\");\n                var errorObj = util.errorObj;\n                var tryCatch = util.tryCatch;\n                var yieldHandlers = [];\n\n                function promiseFromYieldHandler(value, yieldHandlers, traceParent) {\n                    for (var i = 0; i < yieldHandlers.length; ++i) {\n                        traceParent._pushContext();\n                        var result = tryCatch(yieldHandlers[i])(value);\n                        traceParent._popContext();\n                        if (result === errorObj) {\n                            traceParent._pushContext();\n                            var ret = Promise.reject(errorObj.e);\n                            traceParent._popContext();\n                            return ret;\n                        }\n                        var maybePromise = tryConvertToPromise(result, traceParent);\n                        if (maybePromise instanceof Promise) return maybePromise;\n                    }\n                    return null;\n                }\n\n                function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {\n                    if (debug.cancellation()) {\n                        var internal = new Promise(INTERNAL);\n                        var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);\n                        this._promise = internal.lastly(function () {\n                            return _finallyPromise;\n                        });\n                        internal._captureStackTrace();\n                        internal._setOnCancel(this);\n                    } else {\n                        var promise = this._promise = new Promise(INTERNAL);\n                        promise._captureStackTrace();\n                    }\n                    this._stack = stack;\n                    this._generatorFunction = generatorFunction;\n                    this._receiver = receiver;\n                    this._generator = undefined;\n                    this._yieldHandlers = typeof yieldHandler === \"function\" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;\n                    this._yieldedPromise = null;\n                    this._cancellationPhase = false;\n                }\n                util.inherits(PromiseSpawn, Proxyable);\n\n                PromiseSpawn.prototype._isResolved = function () {\n                    return this._promise === null;\n                };\n\n                PromiseSpawn.prototype._cleanup = function () {\n                    this._promise = this._generator = null;\n                    if (debug.cancellation() && this._finallyPromise !== null) {\n                        this._finallyPromise._fulfill();\n                        this._finallyPromise = null;\n                    }\n                };\n\n                PromiseSpawn.prototype._promiseCancelled = function () {\n                    if (this._isResolved()) return;\n                    var implementsReturn = typeof this._generator[\"return\"] !== \"undefined\";\n\n                    var result;\n                    if (!implementsReturn) {\n                        var reason = new Promise.CancellationError(\"generator .return() sentinel\");\n                        Promise.coroutine.returnSentinel = reason;\n                        this._promise._attachExtraTrace(reason);\n                        this._promise._pushContext();\n                        result = tryCatch(this._generator[\"throw\"]).call(this._generator, reason);\n                        this._promise._popContext();\n                    } else {\n                        this._promise._pushContext();\n                        result = tryCatch(this._generator[\"return\"]).call(this._generator, undefined);\n                        this._promise._popContext();\n                    }\n                    this._cancellationPhase = true;\n                    this._yieldedPromise = null;\n                    this._continue(result);\n                };\n\n                PromiseSpawn.prototype._promiseFulfilled = function (value) {\n                    this._yieldedPromise = null;\n                    this._promise._pushContext();\n                    var result = tryCatch(this._generator.next).call(this._generator, value);\n                    this._promise._popContext();\n                    this._continue(result);\n                };\n\n                PromiseSpawn.prototype._promiseRejected = function (reason) {\n                    this._yieldedPromise = null;\n                    this._promise._attachExtraTrace(reason);\n                    this._promise._pushContext();\n                    var result = tryCatch(this._generator[\"throw\"]).call(this._generator, reason);\n                    this._promise._popContext();\n                    this._continue(result);\n                };\n\n                PromiseSpawn.prototype._resultCancelled = function () {\n                    if (this._yieldedPromise instanceof Promise) {\n                        var promise = this._yieldedPromise;\n                        this._yieldedPromise = null;\n                        promise.cancel();\n                    }\n                };\n\n                PromiseSpawn.prototype.promise = function () {\n                    return this._promise;\n                };\n\n                PromiseSpawn.prototype._run = function () {\n                    this._generator = this._generatorFunction.call(this._receiver);\n                    this._receiver = this._generatorFunction = undefined;\n                    this._promiseFulfilled(undefined);\n                };\n\n                PromiseSpawn.prototype._continue = function (result) {\n                    var promise = this._promise;\n                    if (result === errorObj) {\n                        this._cleanup();\n                        if (this._cancellationPhase) {\n                            return promise.cancel();\n                        } else {\n                            return promise._rejectCallback(result.e, false);\n                        }\n                    }\n\n                    var value = result.value;\n                    if (result.done === true) {\n                        this._cleanup();\n                        if (this._cancellationPhase) {\n                            return promise.cancel();\n                        } else {\n                            return promise._resolveCallback(value);\n                        }\n                    } else {\n                        var maybePromise = tryConvertToPromise(value, this._promise);\n                        if (!(maybePromise instanceof Promise)) {\n                            maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);\n                            if (maybePromise === null) {\n                                this._promiseRejected(new TypeError(\"A value %s was yielded that could not be treated as a promise\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\\u000a\".replace(\"%s\", String(value)) + \"From coroutine:\\u000a\" + this._stack.split(\"\\n\").slice(1, -7).join(\"\\n\")));\n                                return;\n                            }\n                        }\n                        maybePromise = maybePromise._target();\n                        var bitField = maybePromise._bitField;\n                        ;\n                        if ((bitField & 50397184) === 0) {\n                            this._yieldedPromise = maybePromise;\n                            maybePromise._proxy(this, null);\n                        } else if ((bitField & 33554432) !== 0) {\n                            Promise._async.invoke(this._promiseFulfilled, this, maybePromise._value());\n                        } else if ((bitField & 16777216) !== 0) {\n                            Promise._async.invoke(this._promiseRejected, this, maybePromise._reason());\n                        } else {\n                            this._promiseCancelled();\n                        }\n                    }\n                };\n\n                Promise.coroutine = function (generatorFunction, options) {\n                    if (typeof generatorFunction !== \"function\") {\n                        throw new TypeError(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n                    }\n                    var yieldHandler = Object(options).yieldHandler;\n                    var PromiseSpawn$ = PromiseSpawn;\n                    var stack = new Error().stack;\n                    return function () {\n                        var generator = generatorFunction.apply(this, arguments);\n                        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler, stack);\n                        var ret = spawn.promise();\n                        spawn._generator = generator;\n                        spawn._promiseFulfilled(undefined);\n                        return ret;\n                    };\n                };\n\n                Promise.coroutine.addYieldHandler = function (fn) {\n                    if (typeof fn !== \"function\") {\n                        throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n                    }\n                    yieldHandlers.push(fn);\n                };\n\n                Promise.spawn = function (generatorFunction) {\n                    debug.deprecated(\"Promise.spawn()\", \"Promise.coroutine()\");\n                    if (typeof generatorFunction !== \"function\") {\n                        return apiRejection(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n                    }\n                    var spawn = new PromiseSpawn(generatorFunction, this);\n                    var ret = spawn.promise();\n                    spawn._run(Promise.spawn);\n                    return ret;\n                };\n            };\n        }, { \"./errors\": 12, \"./util\": 36 }], 17: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain) {\n                var util = _dereq_(\"./util\");\n                var canEvaluate = util.canEvaluate;\n                var tryCatch = util.tryCatch;\n                var errorObj = util.errorObj;\n                var reject;\n\n                if (false) { var i, promiseSetters, thenCallbacks, holderClasses, generateHolderClass, promiseSetter, thenCallback; }\n\n                Promise.join = function () {\n                    var last = arguments.length - 1;\n                    var fn;\n                    if (last > 0 && typeof arguments[last] === \"function\") {\n                        fn = arguments[last];\n                        if (false) { var domain, bitField, maybePromise, i, callbacks, holder, HolderClass, ret; }\n                    }\n                    var args = [].slice.call(arguments);;\n                    if (fn) args.pop();\n                    var ret = new PromiseArray(args).promise();\n                    return fn !== undefined ? ret.spread(fn) : ret;\n                };\n            };\n        }, { \"./util\": 36 }], 18: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {\n                var getDomain = Promise._getDomain;\n                var util = _dereq_(\"./util\");\n                var tryCatch = util.tryCatch;\n                var errorObj = util.errorObj;\n                var async = Promise._async;\n\n                function MappingPromiseArray(promises, fn, limit, _filter) {\n                    this.constructor$(promises);\n                    this._promise._captureStackTrace();\n                    var domain = getDomain();\n                    this._callback = domain === null ? fn : util.domainBind(domain, fn);\n                    this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;\n                    this._limit = limit;\n                    this._inFlight = 0;\n                    this._queue = [];\n                    async.invoke(this._asyncInit, this, undefined);\n                }\n                util.inherits(MappingPromiseArray, PromiseArray);\n\n                MappingPromiseArray.prototype._asyncInit = function () {\n                    this._init$(undefined, -2);\n                };\n\n                MappingPromiseArray.prototype._init = function () {};\n\n                MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {\n                    var values = this._values;\n                    var length = this.length();\n                    var preservedValues = this._preservedValues;\n                    var limit = this._limit;\n\n                    if (index < 0) {\n                        index = index * -1 - 1;\n                        values[index] = value;\n                        if (limit >= 1) {\n                            this._inFlight--;\n                            this._drainQueue();\n                            if (this._isResolved()) return true;\n                        }\n                    } else {\n                        if (limit >= 1 && this._inFlight >= limit) {\n                            values[index] = value;\n                            this._queue.push(index);\n                            return false;\n                        }\n                        if (preservedValues !== null) preservedValues[index] = value;\n\n                        var promise = this._promise;\n                        var callback = this._callback;\n                        var receiver = promise._boundValue();\n                        promise._pushContext();\n                        var ret = tryCatch(callback).call(receiver, value, index, length);\n                        var promiseCreated = promise._popContext();\n                        debug.checkForgottenReturns(ret, promiseCreated, preservedValues !== null ? \"Promise.filter\" : \"Promise.map\", promise);\n                        if (ret === errorObj) {\n                            this._reject(ret.e);\n                            return true;\n                        }\n\n                        var maybePromise = tryConvertToPromise(ret, this._promise);\n                        if (maybePromise instanceof Promise) {\n                            maybePromise = maybePromise._target();\n                            var bitField = maybePromise._bitField;\n                            ;\n                            if ((bitField & 50397184) === 0) {\n                                if (limit >= 1) this._inFlight++;\n                                values[index] = maybePromise;\n                                maybePromise._proxy(this, (index + 1) * -1);\n                                return false;\n                            } else if ((bitField & 33554432) !== 0) {\n                                ret = maybePromise._value();\n                            } else if ((bitField & 16777216) !== 0) {\n                                this._reject(maybePromise._reason());\n                                return true;\n                            } else {\n                                this._cancel();\n                                return true;\n                            }\n                        }\n                        values[index] = ret;\n                    }\n                    var totalResolved = ++this._totalResolved;\n                    if (totalResolved >= length) {\n                        if (preservedValues !== null) {\n                            this._filter(values, preservedValues);\n                        } else {\n                            this._resolve(values);\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n\n                MappingPromiseArray.prototype._drainQueue = function () {\n                    var queue = this._queue;\n                    var limit = this._limit;\n                    var values = this._values;\n                    while (queue.length > 0 && this._inFlight < limit) {\n                        if (this._isResolved()) return;\n                        var index = queue.pop();\n                        this._promiseFulfilled(values[index], index);\n                    }\n                };\n\n                MappingPromiseArray.prototype._filter = function (booleans, values) {\n                    var len = values.length;\n                    var ret = new Array(len);\n                    var j = 0;\n                    for (var i = 0; i < len; ++i) {\n                        if (booleans[i]) ret[j++] = values[i];\n                    }\n                    ret.length = j;\n                    this._resolve(ret);\n                };\n\n                MappingPromiseArray.prototype.preservedValues = function () {\n                    return this._preservedValues;\n                };\n\n                function map(promises, fn, options, _filter) {\n                    if (typeof fn !== \"function\") {\n                        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n                    }\n\n                    var limit = 0;\n                    if (options !== undefined) {\n                        if (typeof options === \"object\" && options !== null) {\n                            if (typeof options.concurrency !== \"number\") {\n                                return Promise.reject(new TypeError(\"'concurrency' must be a number but it is \" + util.classString(options.concurrency)));\n                            }\n                            limit = options.concurrency;\n                        } else {\n                            return Promise.reject(new TypeError(\"options argument must be an object but it is \" + util.classString(options)));\n                        }\n                    }\n                    limit = typeof limit === \"number\" && isFinite(limit) && limit >= 1 ? limit : 0;\n                    return new MappingPromiseArray(promises, fn, limit, _filter).promise();\n                }\n\n                Promise.prototype.map = function (fn, options) {\n                    return map(this, fn, options, null);\n                };\n\n                Promise.map = function (promises, fn, options, _filter) {\n                    return map(promises, fn, options, _filter);\n                };\n            };\n        }, { \"./util\": 36 }], 19: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {\n                var util = _dereq_(\"./util\");\n                var tryCatch = util.tryCatch;\n\n                Promise.method = function (fn) {\n                    if (typeof fn !== \"function\") {\n                        throw new Promise.TypeError(\"expecting a function but got \" + util.classString(fn));\n                    }\n                    return function () {\n                        var ret = new Promise(INTERNAL);\n                        ret._captureStackTrace();\n                        ret._pushContext();\n                        var value = tryCatch(fn).apply(this, arguments);\n                        var promiseCreated = ret._popContext();\n                        debug.checkForgottenReturns(value, promiseCreated, \"Promise.method\", ret);\n                        ret._resolveFromSyncValue(value);\n                        return ret;\n                    };\n                };\n\n                Promise.attempt = Promise[\"try\"] = function (fn) {\n                    if (typeof fn !== \"function\") {\n                        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n                    }\n                    var ret = new Promise(INTERNAL);\n                    ret._captureStackTrace();\n                    ret._pushContext();\n                    var value;\n                    if (arguments.length > 1) {\n                        debug.deprecated(\"calling Promise.try with more than 1 argument\");\n                        var arg = arguments[1];\n                        var ctx = arguments[2];\n                        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);\n                    } else {\n                        value = tryCatch(fn)();\n                    }\n                    var promiseCreated = ret._popContext();\n                    debug.checkForgottenReturns(value, promiseCreated, \"Promise.try\", ret);\n                    ret._resolveFromSyncValue(value);\n                    return ret;\n                };\n\n                Promise.prototype._resolveFromSyncValue = function (value) {\n                    if (value === util.errorObj) {\n                        this._rejectCallback(value.e, false);\n                    } else {\n                        this._resolveCallback(value, true);\n                    }\n                };\n            };\n        }, { \"./util\": 36 }], 20: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            var util = _dereq_(\"./util\");\n            var maybeWrapAsError = util.maybeWrapAsError;\n            var errors = _dereq_(\"./errors\");\n            var OperationalError = errors.OperationalError;\n            var es5 = _dereq_(\"./es5\");\n\n            function isUntypedError(obj) {\n                return obj instanceof Error && es5.getPrototypeOf(obj) === Error.prototype;\n            }\n\n            var rErrorKey = /^(?:name|message|stack|cause)$/;\n            function wrapAsOperationalError(obj) {\n                var ret;\n                if (isUntypedError(obj)) {\n                    ret = new OperationalError(obj);\n                    ret.name = obj.name;\n                    ret.message = obj.message;\n                    ret.stack = obj.stack;\n                    var keys = es5.keys(obj);\n                    for (var i = 0; i < keys.length; ++i) {\n                        var key = keys[i];\n                        if (!rErrorKey.test(key)) {\n                            ret[key] = obj[key];\n                        }\n                    }\n                    return ret;\n                }\n                util.markAsOriginatingFromRejection(obj);\n                return obj;\n            }\n\n            function nodebackForPromise(promise, multiArgs) {\n                return function (err, value) {\n                    if (promise === null) return;\n                    if (err) {\n                        var wrapped = wrapAsOperationalError(maybeWrapAsError(err));\n                        promise._attachExtraTrace(wrapped);\n                        promise._reject(wrapped);\n                    } else if (!multiArgs) {\n                        promise._fulfill(value);\n                    } else {\n                        var args = [].slice.call(arguments, 1);;\n                        promise._fulfill(args);\n                    }\n                    promise = null;\n                };\n            }\n\n            module.exports = nodebackForPromise;\n        }, { \"./errors\": 12, \"./es5\": 13, \"./util\": 36 }], 21: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise) {\n                var util = _dereq_(\"./util\");\n                var async = Promise._async;\n                var tryCatch = util.tryCatch;\n                var errorObj = util.errorObj;\n\n                function spreadAdapter(val, nodeback) {\n                    var promise = this;\n                    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);\n                    var ret = tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));\n                    if (ret === errorObj) {\n                        async.throwLater(ret.e);\n                    }\n                }\n\n                function successAdapter(val, nodeback) {\n                    var promise = this;\n                    var receiver = promise._boundValue();\n                    var ret = val === undefined ? tryCatch(nodeback).call(receiver, null) : tryCatch(nodeback).call(receiver, null, val);\n                    if (ret === errorObj) {\n                        async.throwLater(ret.e);\n                    }\n                }\n                function errorAdapter(reason, nodeback) {\n                    var promise = this;\n                    if (!reason) {\n                        var newReason = new Error(reason + \"\");\n                        newReason.cause = reason;\n                        reason = newReason;\n                    }\n                    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);\n                    if (ret === errorObj) {\n                        async.throwLater(ret.e);\n                    }\n                }\n\n                Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback, options) {\n                    if (typeof nodeback == \"function\") {\n                        var adapter = successAdapter;\n                        if (options !== undefined && Object(options).spread) {\n                            adapter = spreadAdapter;\n                        }\n                        this._then(adapter, errorAdapter, undefined, this, nodeback);\n                    }\n                    return this;\n                };\n            };\n        }, { \"./util\": 36 }], 22: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function () {\n                var makeSelfResolutionError = function () {\n                    return new TypeError(\"circular promise resolution chain\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n                };\n                var reflectHandler = function () {\n                    return new Promise.PromiseInspection(this._target());\n                };\n                var apiRejection = function (msg) {\n                    return Promise.reject(new TypeError(msg));\n                };\n                function Proxyable() {}\n                var UNDEFINED_BINDING = {};\n                var util = _dereq_(\"./util\");\n\n                var getDomain;\n                if (util.isNode) {\n                    getDomain = function () {\n                        var ret = process.domain;\n                        if (ret === undefined) ret = null;\n                        return ret;\n                    };\n                } else {\n                    getDomain = function () {\n                        return null;\n                    };\n                }\n                util.notEnumerableProp(Promise, \"_getDomain\", getDomain);\n\n                var es5 = _dereq_(\"./es5\");\n                var Async = _dereq_(\"./async\");\n                var async = new Async();\n                es5.defineProperty(Promise, \"_async\", { value: async });\n                var errors = _dereq_(\"./errors\");\n                var TypeError = Promise.TypeError = errors.TypeError;\n                Promise.RangeError = errors.RangeError;\n                var CancellationError = Promise.CancellationError = errors.CancellationError;\n                Promise.TimeoutError = errors.TimeoutError;\n                Promise.OperationalError = errors.OperationalError;\n                Promise.RejectionError = errors.OperationalError;\n                Promise.AggregateError = errors.AggregateError;\n                var INTERNAL = function () {};\n                var APPLY = {};\n                var NEXT_FILTER = {};\n                var tryConvertToPromise = _dereq_(\"./thenables\")(Promise, INTERNAL);\n                var PromiseArray = _dereq_(\"./promise_array\")(Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable);\n                var Context = _dereq_(\"./context\")(Promise);\n                /*jshint unused:false*/\n                var createContext = Context.create;\n                var debug = _dereq_(\"./debuggability\")(Promise, Context);\n                var CapturedTrace = debug.CapturedTrace;\n                var PassThroughHandlerContext = _dereq_(\"./finally\")(Promise, tryConvertToPromise, NEXT_FILTER);\n                var catchFilter = _dereq_(\"./catch_filter\")(NEXT_FILTER);\n                var nodebackForPromise = _dereq_(\"./nodeback\");\n                var errorObj = util.errorObj;\n                var tryCatch = util.tryCatch;\n                function check(self, executor) {\n                    if (self == null || self.constructor !== Promise) {\n                        throw new TypeError(\"the promise constructor cannot be invoked directly\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n                    }\n                    if (typeof executor !== \"function\") {\n                        throw new TypeError(\"expecting a function but got \" + util.classString(executor));\n                    }\n                }\n\n                function Promise(executor) {\n                    if (executor !== INTERNAL) {\n                        check(this, executor);\n                    }\n                    this._bitField = 0;\n                    this._fulfillmentHandler0 = undefined;\n                    this._rejectionHandler0 = undefined;\n                    this._promise0 = undefined;\n                    this._receiver0 = undefined;\n                    this._resolveFromExecutor(executor);\n                    this._promiseCreated();\n                    this._fireEvent(\"promiseCreated\", this);\n                }\n\n                Promise.prototype.toString = function () {\n                    return \"[object Promise]\";\n                };\n\n                Promise.prototype.caught = Promise.prototype[\"catch\"] = function (fn) {\n                    var len = arguments.length;\n                    if (len > 1) {\n                        var catchInstances = new Array(len - 1),\n                            j = 0,\n                            i;\n                        for (i = 0; i < len - 1; ++i) {\n                            var item = arguments[i];\n                            if (util.isObject(item)) {\n                                catchInstances[j++] = item;\n                            } else {\n                                return apiRejection(\"Catch statement predicate: \" + \"expecting an object but got \" + util.classString(item));\n                            }\n                        }\n                        catchInstances.length = j;\n                        fn = arguments[i];\n                        return this.then(undefined, catchFilter(catchInstances, fn, this));\n                    }\n                    return this.then(undefined, fn);\n                };\n\n                Promise.prototype.reflect = function () {\n                    return this._then(reflectHandler, reflectHandler, undefined, this, undefined);\n                };\n\n                Promise.prototype.then = function (didFulfill, didReject) {\n                    if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== \"function\" && typeof didReject !== \"function\") {\n                        var msg = \".then() only accepts functions but was passed: \" + util.classString(didFulfill);\n                        if (arguments.length > 1) {\n                            msg += \", \" + util.classString(didReject);\n                        }\n                        this._warn(msg);\n                    }\n                    return this._then(didFulfill, didReject, undefined, undefined, undefined);\n                };\n\n                Promise.prototype.done = function (didFulfill, didReject) {\n                    var promise = this._then(didFulfill, didReject, undefined, undefined, undefined);\n                    promise._setIsFinal();\n                };\n\n                Promise.prototype.spread = function (fn) {\n                    if (typeof fn !== \"function\") {\n                        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n                    }\n                    return this.all()._then(fn, undefined, undefined, APPLY, undefined);\n                };\n\n                Promise.prototype.toJSON = function () {\n                    var ret = {\n                        isFulfilled: false,\n                        isRejected: false,\n                        fulfillmentValue: undefined,\n                        rejectionReason: undefined\n                    };\n                    if (this.isFulfilled()) {\n                        ret.fulfillmentValue = this.value();\n                        ret.isFulfilled = true;\n                    } else if (this.isRejected()) {\n                        ret.rejectionReason = this.reason();\n                        ret.isRejected = true;\n                    }\n                    return ret;\n                };\n\n                Promise.prototype.all = function () {\n                    if (arguments.length > 0) {\n                        this._warn(\".all() was passed arguments but it does not take any\");\n                    }\n                    return new PromiseArray(this).promise();\n                };\n\n                Promise.prototype.error = function (fn) {\n                    return this.caught(util.originatesFromRejection, fn);\n                };\n\n                Promise.getNewLibraryCopy = module.exports;\n\n                Promise.is = function (val) {\n                    return val instanceof Promise;\n                };\n\n                Promise.fromNode = Promise.fromCallback = function (fn) {\n                    var ret = new Promise(INTERNAL);\n                    ret._captureStackTrace();\n                    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;\n                    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));\n                    if (result === errorObj) {\n                        ret._rejectCallback(result.e, true);\n                    }\n                    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();\n                    return ret;\n                };\n\n                Promise.all = function (promises) {\n                    return new PromiseArray(promises).promise();\n                };\n\n                Promise.cast = function (obj) {\n                    var ret = tryConvertToPromise(obj);\n                    if (!(ret instanceof Promise)) {\n                        ret = new Promise(INTERNAL);\n                        ret._captureStackTrace();\n                        ret._setFulfilled();\n                        ret._rejectionHandler0 = obj;\n                    }\n                    return ret;\n                };\n\n                Promise.resolve = Promise.fulfilled = Promise.cast;\n\n                Promise.reject = Promise.rejected = function (reason) {\n                    var ret = new Promise(INTERNAL);\n                    ret._captureStackTrace();\n                    ret._rejectCallback(reason, true);\n                    return ret;\n                };\n\n                Promise.setScheduler = function (fn) {\n                    if (typeof fn !== \"function\") {\n                        throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n                    }\n                    return async.setScheduler(fn);\n                };\n\n                Promise.prototype._then = function (didFulfill, didReject, _, receiver, internalData) {\n                    var haveInternalData = internalData !== undefined;\n                    var promise = haveInternalData ? internalData : new Promise(INTERNAL);\n                    var target = this._target();\n                    var bitField = target._bitField;\n\n                    if (!haveInternalData) {\n                        promise._propagateFrom(this, 3);\n                        promise._captureStackTrace();\n                        if (receiver === undefined && (this._bitField & 2097152) !== 0) {\n                            if (!((bitField & 50397184) === 0)) {\n                                receiver = this._boundValue();\n                            } else {\n                                receiver = target === this ? undefined : this._boundTo;\n                            }\n                        }\n                        this._fireEvent(\"promiseChained\", this, promise);\n                    }\n\n                    var domain = getDomain();\n                    if (!((bitField & 50397184) === 0)) {\n                        var handler,\n                            value,\n                            settler = target._settlePromiseCtx;\n                        if ((bitField & 33554432) !== 0) {\n                            value = target._rejectionHandler0;\n                            handler = didFulfill;\n                        } else if ((bitField & 16777216) !== 0) {\n                            value = target._fulfillmentHandler0;\n                            handler = didReject;\n                            target._unsetRejectionIsUnhandled();\n                        } else {\n                            settler = target._settlePromiseLateCancellationObserver;\n                            value = new CancellationError(\"late cancellation observer\");\n                            target._attachExtraTrace(value);\n                            handler = didReject;\n                        }\n\n                        async.invoke(settler, target, {\n                            handler: domain === null ? handler : typeof handler === \"function\" && util.domainBind(domain, handler),\n                            promise: promise,\n                            receiver: receiver,\n                            value: value\n                        });\n                    } else {\n                        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);\n                    }\n\n                    return promise;\n                };\n\n                Promise.prototype._length = function () {\n                    return this._bitField & 65535;\n                };\n\n                Promise.prototype._isFateSealed = function () {\n                    return (this._bitField & 117506048) !== 0;\n                };\n\n                Promise.prototype._isFollowing = function () {\n                    return (this._bitField & 67108864) === 67108864;\n                };\n\n                Promise.prototype._setLength = function (len) {\n                    this._bitField = this._bitField & -65536 | len & 65535;\n                };\n\n                Promise.prototype._setFulfilled = function () {\n                    this._bitField = this._bitField | 33554432;\n                    this._fireEvent(\"promiseFulfilled\", this);\n                };\n\n                Promise.prototype._setRejected = function () {\n                    this._bitField = this._bitField | 16777216;\n                    this._fireEvent(\"promiseRejected\", this);\n                };\n\n                Promise.prototype._setFollowing = function () {\n                    this._bitField = this._bitField | 67108864;\n                    this._fireEvent(\"promiseResolved\", this);\n                };\n\n                Promise.prototype._setIsFinal = function () {\n                    this._bitField = this._bitField | 4194304;\n                };\n\n                Promise.prototype._isFinal = function () {\n                    return (this._bitField & 4194304) > 0;\n                };\n\n                Promise.prototype._unsetCancelled = function () {\n                    this._bitField = this._bitField & ~65536;\n                };\n\n                Promise.prototype._setCancelled = function () {\n                    this._bitField = this._bitField | 65536;\n                    this._fireEvent(\"promiseCancelled\", this);\n                };\n\n                Promise.prototype._setWillBeCancelled = function () {\n                    this._bitField = this._bitField | 8388608;\n                };\n\n                Promise.prototype._setAsyncGuaranteed = function () {\n                    if (async.hasCustomScheduler()) return;\n                    this._bitField = this._bitField | 134217728;\n                };\n\n                Promise.prototype._receiverAt = function (index) {\n                    var ret = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];\n                    if (ret === UNDEFINED_BINDING) {\n                        return undefined;\n                    } else if (ret === undefined && this._isBound()) {\n                        return this._boundValue();\n                    }\n                    return ret;\n                };\n\n                Promise.prototype._promiseAt = function (index) {\n                    return this[index * 4 - 4 + 2];\n                };\n\n                Promise.prototype._fulfillmentHandlerAt = function (index) {\n                    return this[index * 4 - 4 + 0];\n                };\n\n                Promise.prototype._rejectionHandlerAt = function (index) {\n                    return this[index * 4 - 4 + 1];\n                };\n\n                Promise.prototype._boundValue = function () {};\n\n                Promise.prototype._migrateCallback0 = function (follower) {\n                    var bitField = follower._bitField;\n                    var fulfill = follower._fulfillmentHandler0;\n                    var reject = follower._rejectionHandler0;\n                    var promise = follower._promise0;\n                    var receiver = follower._receiverAt(0);\n                    if (receiver === undefined) receiver = UNDEFINED_BINDING;\n                    this._addCallbacks(fulfill, reject, promise, receiver, null);\n                };\n\n                Promise.prototype._migrateCallbackAt = function (follower, index) {\n                    var fulfill = follower._fulfillmentHandlerAt(index);\n                    var reject = follower._rejectionHandlerAt(index);\n                    var promise = follower._promiseAt(index);\n                    var receiver = follower._receiverAt(index);\n                    if (receiver === undefined) receiver = UNDEFINED_BINDING;\n                    this._addCallbacks(fulfill, reject, promise, receiver, null);\n                };\n\n                Promise.prototype._addCallbacks = function (fulfill, reject, promise, receiver, domain) {\n                    var index = this._length();\n\n                    if (index >= 65535 - 4) {\n                        index = 0;\n                        this._setLength(0);\n                    }\n\n                    if (index === 0) {\n                        this._promise0 = promise;\n                        this._receiver0 = receiver;\n                        if (typeof fulfill === \"function\") {\n                            this._fulfillmentHandler0 = domain === null ? fulfill : util.domainBind(domain, fulfill);\n                        }\n                        if (typeof reject === \"function\") {\n                            this._rejectionHandler0 = domain === null ? reject : util.domainBind(domain, reject);\n                        }\n                    } else {\n                        var base = index * 4 - 4;\n                        this[base + 2] = promise;\n                        this[base + 3] = receiver;\n                        if (typeof fulfill === \"function\") {\n                            this[base + 0] = domain === null ? fulfill : util.domainBind(domain, fulfill);\n                        }\n                        if (typeof reject === \"function\") {\n                            this[base + 1] = domain === null ? reject : util.domainBind(domain, reject);\n                        }\n                    }\n                    this._setLength(index + 1);\n                    return index;\n                };\n\n                Promise.prototype._proxy = function (proxyable, arg) {\n                    this._addCallbacks(undefined, undefined, arg, proxyable, null);\n                };\n\n                Promise.prototype._resolveCallback = function (value, shouldBind) {\n                    if ((this._bitField & 117506048) !== 0) return;\n                    if (value === this) return this._rejectCallback(makeSelfResolutionError(), false);\n                    var maybePromise = tryConvertToPromise(value, this);\n                    if (!(maybePromise instanceof Promise)) return this._fulfill(value);\n\n                    if (shouldBind) this._propagateFrom(maybePromise, 2);\n\n                    var promise = maybePromise._target();\n\n                    if (promise === this) {\n                        this._reject(makeSelfResolutionError());\n                        return;\n                    }\n\n                    var bitField = promise._bitField;\n                    if ((bitField & 50397184) === 0) {\n                        var len = this._length();\n                        if (len > 0) promise._migrateCallback0(this);\n                        for (var i = 1; i < len; ++i) {\n                            promise._migrateCallbackAt(this, i);\n                        }\n                        this._setFollowing();\n                        this._setLength(0);\n                        this._setFollowee(promise);\n                    } else if ((bitField & 33554432) !== 0) {\n                        this._fulfill(promise._value());\n                    } else if ((bitField & 16777216) !== 0) {\n                        this._reject(promise._reason());\n                    } else {\n                        var reason = new CancellationError(\"late cancellation observer\");\n                        promise._attachExtraTrace(reason);\n                        this._reject(reason);\n                    }\n                };\n\n                Promise.prototype._rejectCallback = function (reason, synchronous, ignoreNonErrorWarnings) {\n                    var trace = util.ensureErrorObject(reason);\n                    var hasStack = trace === reason;\n                    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {\n                        var message = \"a promise was rejected with a non-error: \" + util.classString(reason);\n                        this._warn(message, true);\n                    }\n                    this._attachExtraTrace(trace, synchronous ? hasStack : false);\n                    this._reject(reason);\n                };\n\n                Promise.prototype._resolveFromExecutor = function (executor) {\n                    if (executor === INTERNAL) return;\n                    var promise = this;\n                    this._captureStackTrace();\n                    this._pushContext();\n                    var synchronous = true;\n                    var r = this._execute(executor, function (value) {\n                        promise._resolveCallback(value);\n                    }, function (reason) {\n                        promise._rejectCallback(reason, synchronous);\n                    });\n                    synchronous = false;\n                    this._popContext();\n\n                    if (r !== undefined) {\n                        promise._rejectCallback(r, true);\n                    }\n                };\n\n                Promise.prototype._settlePromiseFromHandler = function (handler, receiver, value, promise) {\n                    var bitField = promise._bitField;\n                    if ((bitField & 65536) !== 0) return;\n                    promise._pushContext();\n                    var x;\n                    if (receiver === APPLY) {\n                        if (!value || typeof value.length !== \"number\") {\n                            x = errorObj;\n                            x.e = new TypeError(\"cannot .spread() a non-array: \" + util.classString(value));\n                        } else {\n                            x = tryCatch(handler).apply(this._boundValue(), value);\n                        }\n                    } else {\n                        x = tryCatch(handler).call(receiver, value);\n                    }\n                    var promiseCreated = promise._popContext();\n                    bitField = promise._bitField;\n                    if ((bitField & 65536) !== 0) return;\n\n                    if (x === NEXT_FILTER) {\n                        promise._reject(value);\n                    } else if (x === errorObj) {\n                        promise._rejectCallback(x.e, false);\n                    } else {\n                        debug.checkForgottenReturns(x, promiseCreated, \"\", promise, this);\n                        promise._resolveCallback(x);\n                    }\n                };\n\n                Promise.prototype._target = function () {\n                    var ret = this;\n                    while (ret._isFollowing()) ret = ret._followee();\n                    return ret;\n                };\n\n                Promise.prototype._followee = function () {\n                    return this._rejectionHandler0;\n                };\n\n                Promise.prototype._setFollowee = function (promise) {\n                    this._rejectionHandler0 = promise;\n                };\n\n                Promise.prototype._settlePromise = function (promise, handler, receiver, value) {\n                    var isPromise = promise instanceof Promise;\n                    var bitField = this._bitField;\n                    var asyncGuaranteed = (bitField & 134217728) !== 0;\n                    if ((bitField & 65536) !== 0) {\n                        if (isPromise) promise._invokeInternalOnCancel();\n\n                        if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {\n                            receiver.cancelPromise = promise;\n                            if (tryCatch(handler).call(receiver, value) === errorObj) {\n                                promise._reject(errorObj.e);\n                            }\n                        } else if (handler === reflectHandler) {\n                            promise._fulfill(reflectHandler.call(receiver));\n                        } else if (receiver instanceof Proxyable) {\n                            receiver._promiseCancelled(promise);\n                        } else if (isPromise || promise instanceof PromiseArray) {\n                            promise._cancel();\n                        } else {\n                            receiver.cancel();\n                        }\n                    } else if (typeof handler === \"function\") {\n                        if (!isPromise) {\n                            handler.call(receiver, value, promise);\n                        } else {\n                            if (asyncGuaranteed) promise._setAsyncGuaranteed();\n                            this._settlePromiseFromHandler(handler, receiver, value, promise);\n                        }\n                    } else if (receiver instanceof Proxyable) {\n                        if (!receiver._isResolved()) {\n                            if ((bitField & 33554432) !== 0) {\n                                receiver._promiseFulfilled(value, promise);\n                            } else {\n                                receiver._promiseRejected(value, promise);\n                            }\n                        }\n                    } else if (isPromise) {\n                        if (asyncGuaranteed) promise._setAsyncGuaranteed();\n                        if ((bitField & 33554432) !== 0) {\n                            promise._fulfill(value);\n                        } else {\n                            promise._reject(value);\n                        }\n                    }\n                };\n\n                Promise.prototype._settlePromiseLateCancellationObserver = function (ctx) {\n                    var handler = ctx.handler;\n                    var promise = ctx.promise;\n                    var receiver = ctx.receiver;\n                    var value = ctx.value;\n                    if (typeof handler === \"function\") {\n                        if (!(promise instanceof Promise)) {\n                            handler.call(receiver, value, promise);\n                        } else {\n                            this._settlePromiseFromHandler(handler, receiver, value, promise);\n                        }\n                    } else if (promise instanceof Promise) {\n                        promise._reject(value);\n                    }\n                };\n\n                Promise.prototype._settlePromiseCtx = function (ctx) {\n                    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);\n                };\n\n                Promise.prototype._settlePromise0 = function (handler, value, bitField) {\n                    var promise = this._promise0;\n                    var receiver = this._receiverAt(0);\n                    this._promise0 = undefined;\n                    this._receiver0 = undefined;\n                    this._settlePromise(promise, handler, receiver, value);\n                };\n\n                Promise.prototype._clearCallbackDataAtIndex = function (index) {\n                    var base = index * 4 - 4;\n                    this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = undefined;\n                };\n\n                Promise.prototype._fulfill = function (value) {\n                    var bitField = this._bitField;\n                    if ((bitField & 117506048) >>> 16) return;\n                    if (value === this) {\n                        var err = makeSelfResolutionError();\n                        this._attachExtraTrace(err);\n                        return this._reject(err);\n                    }\n                    this._setFulfilled();\n                    this._rejectionHandler0 = value;\n\n                    if ((bitField & 65535) > 0) {\n                        if ((bitField & 134217728) !== 0) {\n                            this._settlePromises();\n                        } else {\n                            async.settlePromises(this);\n                        }\n                    }\n                };\n\n                Promise.prototype._reject = function (reason) {\n                    var bitField = this._bitField;\n                    if ((bitField & 117506048) >>> 16) return;\n                    this._setRejected();\n                    this._fulfillmentHandler0 = reason;\n\n                    if (this._isFinal()) {\n                        return async.fatalError(reason, util.isNode);\n                    }\n\n                    if ((bitField & 65535) > 0) {\n                        async.settlePromises(this);\n                    } else {\n                        this._ensurePossibleRejectionHandled();\n                    }\n                };\n\n                Promise.prototype._fulfillPromises = function (len, value) {\n                    for (var i = 1; i < len; i++) {\n                        var handler = this._fulfillmentHandlerAt(i);\n                        var promise = this._promiseAt(i);\n                        var receiver = this._receiverAt(i);\n                        this._clearCallbackDataAtIndex(i);\n                        this._settlePromise(promise, handler, receiver, value);\n                    }\n                };\n\n                Promise.prototype._rejectPromises = function (len, reason) {\n                    for (var i = 1; i < len; i++) {\n                        var handler = this._rejectionHandlerAt(i);\n                        var promise = this._promiseAt(i);\n                        var receiver = this._receiverAt(i);\n                        this._clearCallbackDataAtIndex(i);\n                        this._settlePromise(promise, handler, receiver, reason);\n                    }\n                };\n\n                Promise.prototype._settlePromises = function () {\n                    var bitField = this._bitField;\n                    var len = bitField & 65535;\n\n                    if (len > 0) {\n                        if ((bitField & 16842752) !== 0) {\n                            var reason = this._fulfillmentHandler0;\n                            this._settlePromise0(this._rejectionHandler0, reason, bitField);\n                            this._rejectPromises(len, reason);\n                        } else {\n                            var value = this._rejectionHandler0;\n                            this._settlePromise0(this._fulfillmentHandler0, value, bitField);\n                            this._fulfillPromises(len, value);\n                        }\n                        this._setLength(0);\n                    }\n                    this._clearCancellationData();\n                };\n\n                Promise.prototype._settledValue = function () {\n                    var bitField = this._bitField;\n                    if ((bitField & 33554432) !== 0) {\n                        return this._rejectionHandler0;\n                    } else if ((bitField & 16777216) !== 0) {\n                        return this._fulfillmentHandler0;\n                    }\n                };\n\n                function deferResolve(v) {\n                    this.promise._resolveCallback(v);\n                }\n                function deferReject(v) {\n                    this.promise._rejectCallback(v, false);\n                }\n\n                Promise.defer = Promise.pending = function () {\n                    debug.deprecated(\"Promise.defer\", \"new Promise\");\n                    var promise = new Promise(INTERNAL);\n                    return {\n                        promise: promise,\n                        resolve: deferResolve,\n                        reject: deferReject\n                    };\n                };\n\n                util.notEnumerableProp(Promise, \"_makeSelfResolutionError\", makeSelfResolutionError);\n\n                _dereq_(\"./method\")(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug);\n                _dereq_(\"./bind\")(Promise, INTERNAL, tryConvertToPromise, debug);\n                _dereq_(\"./cancel\")(Promise, PromiseArray, apiRejection, debug);\n                _dereq_(\"./direct_resolve\")(Promise);\n                _dereq_(\"./synchronous_inspection\")(Promise);\n                _dereq_(\"./join\")(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);\n                Promise.Promise = Promise;\n                Promise.version = \"3.5.1\";\n                _dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);\n                _dereq_('./call_get.js')(Promise);\n                _dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);\n                _dereq_('./timers.js')(Promise, INTERNAL, debug);\n                _dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);\n                _dereq_('./nodeify.js')(Promise);\n                _dereq_('./promisify.js')(Promise, INTERNAL);\n                _dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);\n                _dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);\n                _dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);\n                _dereq_('./settle.js')(Promise, PromiseArray, debug);\n                _dereq_('./some.js')(Promise, PromiseArray, apiRejection);\n                _dereq_('./filter.js')(Promise, INTERNAL);\n                _dereq_('./each.js')(Promise, INTERNAL);\n                _dereq_('./any.js')(Promise);\n\n                util.toFastProperties(Promise);\n                util.toFastProperties(Promise.prototype);\n                function fillTypes(value) {\n                    var p = new Promise(INTERNAL);\n                    p._fulfillmentHandler0 = value;\n                    p._rejectionHandler0 = value;\n                    p._promise0 = value;\n                    p._receiver0 = value;\n                }\n                // Complete slack tracking, opt out of field-type tracking and           \n                // stabilize map                                                         \n                fillTypes({ a: 1 });\n                fillTypes({ b: 2 });\n                fillTypes({ c: 3 });\n                fillTypes(1);\n                fillTypes(function () {});\n                fillTypes(undefined);\n                fillTypes(false);\n                fillTypes(new Promise(INTERNAL));\n                debug.setBounds(Async.firstLineError, util.lastLineError);\n                return Promise;\n            };\n        }, { \"./any.js\": 1, \"./async\": 2, \"./bind\": 3, \"./call_get.js\": 5, \"./cancel\": 6, \"./catch_filter\": 7, \"./context\": 8, \"./debuggability\": 9, \"./direct_resolve\": 10, \"./each.js\": 11, \"./errors\": 12, \"./es5\": 13, \"./filter.js\": 14, \"./finally\": 15, \"./generators.js\": 16, \"./join\": 17, \"./map.js\": 18, \"./method\": 19, \"./nodeback\": 20, \"./nodeify.js\": 21, \"./promise_array\": 23, \"./promisify.js\": 24, \"./props.js\": 25, \"./race.js\": 27, \"./reduce.js\": 28, \"./settle.js\": 30, \"./some.js\": 31, \"./synchronous_inspection\": 32, \"./thenables\": 33, \"./timers.js\": 34, \"./using.js\": 35, \"./util\": 36 }], 23: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {\n                var util = _dereq_(\"./util\");\n                var isArray = util.isArray;\n\n                function toResolutionValue(val) {\n                    switch (val) {\n                        case -2:\n                            return [];\n                        case -3:\n                            return {};\n                        case -6:\n                            return new Map();\n                    }\n                }\n\n                function PromiseArray(values) {\n                    var promise = this._promise = new Promise(INTERNAL);\n                    if (values instanceof Promise) {\n                        promise._propagateFrom(values, 3);\n                    }\n                    promise._setOnCancel(this);\n                    this._values = values;\n                    this._length = 0;\n                    this._totalResolved = 0;\n                    this._init(undefined, -2);\n                }\n                util.inherits(PromiseArray, Proxyable);\n\n                PromiseArray.prototype.length = function () {\n                    return this._length;\n                };\n\n                PromiseArray.prototype.promise = function () {\n                    return this._promise;\n                };\n\n                PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {\n                    var values = tryConvertToPromise(this._values, this._promise);\n                    if (values instanceof Promise) {\n                        values = values._target();\n                        var bitField = values._bitField;\n                        ;\n                        this._values = values;\n\n                        if ((bitField & 50397184) === 0) {\n                            this._promise._setAsyncGuaranteed();\n                            return values._then(init, this._reject, undefined, this, resolveValueIfEmpty);\n                        } else if ((bitField & 33554432) !== 0) {\n                            values = values._value();\n                        } else if ((bitField & 16777216) !== 0) {\n                            return this._reject(values._reason());\n                        } else {\n                            return this._cancel();\n                        }\n                    }\n                    values = util.asArray(values);\n                    if (values === null) {\n                        var err = apiRejection(\"expecting an array or an iterable object but got \" + util.classString(values)).reason();\n                        this._promise._rejectCallback(err, false);\n                        return;\n                    }\n\n                    if (values.length === 0) {\n                        if (resolveValueIfEmpty === -5) {\n                            this._resolveEmptyArray();\n                        } else {\n                            this._resolve(toResolutionValue(resolveValueIfEmpty));\n                        }\n                        return;\n                    }\n                    this._iterate(values);\n                };\n\n                PromiseArray.prototype._iterate = function (values) {\n                    var len = this.getActualLength(values.length);\n                    this._length = len;\n                    this._values = this.shouldCopyValues() ? new Array(len) : this._values;\n                    var result = this._promise;\n                    var isResolved = false;\n                    var bitField = null;\n                    for (var i = 0; i < len; ++i) {\n                        var maybePromise = tryConvertToPromise(values[i], result);\n\n                        if (maybePromise instanceof Promise) {\n                            maybePromise = maybePromise._target();\n                            bitField = maybePromise._bitField;\n                        } else {\n                            bitField = null;\n                        }\n\n                        if (isResolved) {\n                            if (bitField !== null) {\n                                maybePromise.suppressUnhandledRejections();\n                            }\n                        } else if (bitField !== null) {\n                            if ((bitField & 50397184) === 0) {\n                                maybePromise._proxy(this, i);\n                                this._values[i] = maybePromise;\n                            } else if ((bitField & 33554432) !== 0) {\n                                isResolved = this._promiseFulfilled(maybePromise._value(), i);\n                            } else if ((bitField & 16777216) !== 0) {\n                                isResolved = this._promiseRejected(maybePromise._reason(), i);\n                            } else {\n                                isResolved = this._promiseCancelled(i);\n                            }\n                        } else {\n                            isResolved = this._promiseFulfilled(maybePromise, i);\n                        }\n                    }\n                    if (!isResolved) result._setAsyncGuaranteed();\n                };\n\n                PromiseArray.prototype._isResolved = function () {\n                    return this._values === null;\n                };\n\n                PromiseArray.prototype._resolve = function (value) {\n                    this._values = null;\n                    this._promise._fulfill(value);\n                };\n\n                PromiseArray.prototype._cancel = function () {\n                    if (this._isResolved() || !this._promise._isCancellable()) return;\n                    this._values = null;\n                    this._promise._cancel();\n                };\n\n                PromiseArray.prototype._reject = function (reason) {\n                    this._values = null;\n                    this._promise._rejectCallback(reason, false);\n                };\n\n                PromiseArray.prototype._promiseFulfilled = function (value, index) {\n                    this._values[index] = value;\n                    var totalResolved = ++this._totalResolved;\n                    if (totalResolved >= this._length) {\n                        this._resolve(this._values);\n                        return true;\n                    }\n                    return false;\n                };\n\n                PromiseArray.prototype._promiseCancelled = function () {\n                    this._cancel();\n                    return true;\n                };\n\n                PromiseArray.prototype._promiseRejected = function (reason) {\n                    this._totalResolved++;\n                    this._reject(reason);\n                    return true;\n                };\n\n                PromiseArray.prototype._resultCancelled = function () {\n                    if (this._isResolved()) return;\n                    var values = this._values;\n                    this._cancel();\n                    if (values instanceof Promise) {\n                        values.cancel();\n                    } else {\n                        for (var i = 0; i < values.length; ++i) {\n                            if (values[i] instanceof Promise) {\n                                values[i].cancel();\n                            }\n                        }\n                    }\n                };\n\n                PromiseArray.prototype.shouldCopyValues = function () {\n                    return true;\n                };\n\n                PromiseArray.prototype.getActualLength = function (len) {\n                    return len;\n                };\n\n                return PromiseArray;\n            };\n        }, { \"./util\": 36 }], 24: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, INTERNAL) {\n                var THIS = {};\n                var util = _dereq_(\"./util\");\n                var nodebackForPromise = _dereq_(\"./nodeback\");\n                var withAppended = util.withAppended;\n                var maybeWrapAsError = util.maybeWrapAsError;\n                var canEvaluate = util.canEvaluate;\n                var TypeError = _dereq_(\"./errors\").TypeError;\n                var defaultSuffix = \"Async\";\n                var defaultPromisified = { __isPromisified__: true };\n                var noCopyProps = [\"arity\", \"length\", \"name\", \"arguments\", \"caller\", \"callee\", \"prototype\", \"__isPromisified__\"];\n                var noCopyPropsPattern = new RegExp(\"^(?:\" + noCopyProps.join(\"|\") + \")$\");\n\n                var defaultFilter = function (name) {\n                    return util.isIdentifier(name) && name.charAt(0) !== \"_\" && name !== \"constructor\";\n                };\n\n                function propsFilter(key) {\n                    return !noCopyPropsPattern.test(key);\n                }\n\n                function isPromisified(fn) {\n                    try {\n                        return fn.__isPromisified__ === true;\n                    } catch (e) {\n                        return false;\n                    }\n                }\n\n                function hasPromisified(obj, key, suffix) {\n                    var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);\n                    return val ? isPromisified(val) : false;\n                }\n                function checkValid(ret, suffix, suffixRegexp) {\n                    for (var i = 0; i < ret.length; i += 2) {\n                        var key = ret[i];\n                        if (suffixRegexp.test(key)) {\n                            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, \"\");\n                            for (var j = 0; j < ret.length; j += 2) {\n                                if (ret[j] === keyWithoutAsyncSuffix) {\n                                    throw new TypeError(\"Cannot promisify an API that has normal methods with '%s'-suffix\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\".replace(\"%s\", suffix));\n                                }\n                            }\n                        }\n                    }\n                }\n\n                function promisifiableMethods(obj, suffix, suffixRegexp, filter) {\n                    var keys = util.inheritedDataKeys(obj);\n                    var ret = [];\n                    for (var i = 0; i < keys.length; ++i) {\n                        var key = keys[i];\n                        var value = obj[key];\n                        var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj);\n                        if (typeof value === \"function\" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter(key, value, obj, passesDefaultFilter)) {\n                            ret.push(key, value);\n                        }\n                    }\n                    checkValid(ret, suffix, suffixRegexp);\n                    return ret;\n                }\n\n                var escapeIdentRegex = function (str) {\n                    return str.replace(/([$])/, \"\\\\$\");\n                };\n\n                var makeNodePromisifiedEval;\n                if (false) { var parameterCount, parameterDeclaration, argumentSequence, switchCaseArgumentOrder; }\n\n                function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {\n                    var defaultThis = function () {\n                        return this;\n                    }();\n                    var method = callback;\n                    if (typeof method === \"string\") {\n                        callback = fn;\n                    }\n                    function promisified() {\n                        var _receiver = receiver;\n                        if (receiver === THIS) _receiver = this;\n                        var promise = new Promise(INTERNAL);\n                        promise._captureStackTrace();\n                        var cb = typeof method === \"string\" && this !== defaultThis ? this[method] : callback;\n                        var fn = nodebackForPromise(promise, multiArgs);\n                        try {\n                            cb.apply(_receiver, withAppended(arguments, fn));\n                        } catch (e) {\n                            promise._rejectCallback(maybeWrapAsError(e), true, true);\n                        }\n                        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();\n                        return promise;\n                    }\n                    util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n                    return promisified;\n                }\n\n                var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;\n\n                function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {\n                    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + \"$\");\n                    var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter);\n\n                    for (var i = 0, len = methods.length; i < len; i += 2) {\n                        var key = methods[i];\n                        var fn = methods[i + 1];\n                        var promisifiedKey = key + suffix;\n                        if (promisifier === makeNodePromisified) {\n                            obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);\n                        } else {\n                            var promisified = promisifier(fn, function () {\n                                return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);\n                            });\n                            util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n                            obj[promisifiedKey] = promisified;\n                        }\n                    }\n                    util.toFastProperties(obj);\n                    return obj;\n                }\n\n                function promisify(callback, receiver, multiArgs) {\n                    return makeNodePromisified(callback, receiver, undefined, callback, null, multiArgs);\n                }\n\n                Promise.promisify = function (fn, options) {\n                    if (typeof fn !== \"function\") {\n                        throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n                    }\n                    if (isPromisified(fn)) {\n                        return fn;\n                    }\n                    options = Object(options);\n                    var receiver = options.context === undefined ? THIS : options.context;\n                    var multiArgs = !!options.multiArgs;\n                    var ret = promisify(fn, receiver, multiArgs);\n                    util.copyDescriptors(fn, ret, propsFilter);\n                    return ret;\n                };\n\n                Promise.promisifyAll = function (target, options) {\n                    if (typeof target !== \"function\" && typeof target !== \"object\") {\n                        throw new TypeError(\"the target of promisifyAll must be an object or a function\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n                    }\n                    options = Object(options);\n                    var multiArgs = !!options.multiArgs;\n                    var suffix = options.suffix;\n                    if (typeof suffix !== \"string\") suffix = defaultSuffix;\n                    var filter = options.filter;\n                    if (typeof filter !== \"function\") filter = defaultFilter;\n                    var promisifier = options.promisifier;\n                    if (typeof promisifier !== \"function\") promisifier = makeNodePromisified;\n\n                    if (!util.isIdentifier(suffix)) {\n                        throw new RangeError(\"suffix must be a valid identifier\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n                    }\n\n                    var keys = util.inheritedDataKeys(target);\n                    for (var i = 0; i < keys.length; ++i) {\n                        var value = target[keys[i]];\n                        if (keys[i] !== \"constructor\" && util.isClass(value)) {\n                            promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs);\n                            promisifyAll(value, suffix, filter, promisifier, multiArgs);\n                        }\n                    }\n\n                    return promisifyAll(target, suffix, filter, promisifier, multiArgs);\n                };\n            };\n        }, { \"./errors\": 12, \"./nodeback\": 20, \"./util\": 36 }], 25: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, PromiseArray, tryConvertToPromise, apiRejection) {\n                var util = _dereq_(\"./util\");\n                var isObject = util.isObject;\n                var es5 = _dereq_(\"./es5\");\n                var Es6Map;\n                if (typeof Map === \"function\") Es6Map = Map;\n\n                var mapToEntries = function () {\n                    var index = 0;\n                    var size = 0;\n\n                    function extractEntry(value, key) {\n                        this[index] = value;\n                        this[index + size] = key;\n                        index++;\n                    }\n\n                    return function mapToEntries(map) {\n                        size = map.size;\n                        index = 0;\n                        var ret = new Array(map.size * 2);\n                        map.forEach(extractEntry, ret);\n                        return ret;\n                    };\n                }();\n\n                var entriesToMap = function (entries) {\n                    var ret = new Es6Map();\n                    var length = entries.length / 2 | 0;\n                    for (var i = 0; i < length; ++i) {\n                        var key = entries[length + i];\n                        var value = entries[i];\n                        ret.set(key, value);\n                    }\n                    return ret;\n                };\n\n                function PropertiesPromiseArray(obj) {\n                    var isMap = false;\n                    var entries;\n                    if (Es6Map !== undefined && obj instanceof Es6Map) {\n                        entries = mapToEntries(obj);\n                        isMap = true;\n                    } else {\n                        var keys = es5.keys(obj);\n                        var len = keys.length;\n                        entries = new Array(len * 2);\n                        for (var i = 0; i < len; ++i) {\n                            var key = keys[i];\n                            entries[i] = obj[key];\n                            entries[i + len] = key;\n                        }\n                    }\n                    this.constructor$(entries);\n                    this._isMap = isMap;\n                    this._init$(undefined, isMap ? -6 : -3);\n                }\n                util.inherits(PropertiesPromiseArray, PromiseArray);\n\n                PropertiesPromiseArray.prototype._init = function () {};\n\n                PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {\n                    this._values[index] = value;\n                    var totalResolved = ++this._totalResolved;\n                    if (totalResolved >= this._length) {\n                        var val;\n                        if (this._isMap) {\n                            val = entriesToMap(this._values);\n                        } else {\n                            val = {};\n                            var keyOffset = this.length();\n                            for (var i = 0, len = this.length(); i < len; ++i) {\n                                val[this._values[i + keyOffset]] = this._values[i];\n                            }\n                        }\n                        this._resolve(val);\n                        return true;\n                    }\n                    return false;\n                };\n\n                PropertiesPromiseArray.prototype.shouldCopyValues = function () {\n                    return false;\n                };\n\n                PropertiesPromiseArray.prototype.getActualLength = function (len) {\n                    return len >> 1;\n                };\n\n                function props(promises) {\n                    var ret;\n                    var castValue = tryConvertToPromise(promises);\n\n                    if (!isObject(castValue)) {\n                        return apiRejection(\"cannot await properties of a non-object\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n                    } else if (castValue instanceof Promise) {\n                        ret = castValue._then(Promise.props, undefined, undefined, undefined, undefined);\n                    } else {\n                        ret = new PropertiesPromiseArray(castValue).promise();\n                    }\n\n                    if (castValue instanceof Promise) {\n                        ret._propagateFrom(castValue, 2);\n                    }\n                    return ret;\n                }\n\n                Promise.prototype.props = function () {\n                    return props(this);\n                };\n\n                Promise.props = function (promises) {\n                    return props(promises);\n                };\n            };\n        }, { \"./es5\": 13, \"./util\": 36 }], 26: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            function arrayMove(src, srcIndex, dst, dstIndex, len) {\n                for (var j = 0; j < len; ++j) {\n                    dst[j + dstIndex] = src[j + srcIndex];\n                    src[j + srcIndex] = void 0;\n                }\n            }\n\n            function Queue(capacity) {\n                this._capacity = capacity;\n                this._length = 0;\n                this._front = 0;\n            }\n\n            Queue.prototype._willBeOverCapacity = function (size) {\n                return this._capacity < size;\n            };\n\n            Queue.prototype._pushOne = function (arg) {\n                var length = this.length();\n                this._checkCapacity(length + 1);\n                var i = this._front + length & this._capacity - 1;\n                this[i] = arg;\n                this._length = length + 1;\n            };\n\n            Queue.prototype.push = function (fn, receiver, arg) {\n                var length = this.length() + 3;\n                if (this._willBeOverCapacity(length)) {\n                    this._pushOne(fn);\n                    this._pushOne(receiver);\n                    this._pushOne(arg);\n                    return;\n                }\n                var j = this._front + length - 3;\n                this._checkCapacity(length);\n                var wrapMask = this._capacity - 1;\n                this[j + 0 & wrapMask] = fn;\n                this[j + 1 & wrapMask] = receiver;\n                this[j + 2 & wrapMask] = arg;\n                this._length = length;\n            };\n\n            Queue.prototype.shift = function () {\n                var front = this._front,\n                    ret = this[front];\n\n                this[front] = undefined;\n                this._front = front + 1 & this._capacity - 1;\n                this._length--;\n                return ret;\n            };\n\n            Queue.prototype.length = function () {\n                return this._length;\n            };\n\n            Queue.prototype._checkCapacity = function (size) {\n                if (this._capacity < size) {\n                    this._resizeTo(this._capacity << 1);\n                }\n            };\n\n            Queue.prototype._resizeTo = function (capacity) {\n                var oldCapacity = this._capacity;\n                this._capacity = capacity;\n                var front = this._front;\n                var length = this._length;\n                var moveItemsCount = front + length & oldCapacity - 1;\n                arrayMove(this, 0, this, oldCapacity, moveItemsCount);\n            };\n\n            module.exports = Queue;\n        }, {}], 27: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection) {\n                var util = _dereq_(\"./util\");\n\n                var raceLater = function (promise) {\n                    return promise.then(function (array) {\n                        return race(array, promise);\n                    });\n                };\n\n                function race(promises, parent) {\n                    var maybePromise = tryConvertToPromise(promises);\n\n                    if (maybePromise instanceof Promise) {\n                        return raceLater(maybePromise);\n                    } else {\n                        promises = util.asArray(promises);\n                        if (promises === null) return apiRejection(\"expecting an array or an iterable object but got \" + util.classString(promises));\n                    }\n\n                    var ret = new Promise(INTERNAL);\n                    if (parent !== undefined) {\n                        ret._propagateFrom(parent, 3);\n                    }\n                    var fulfill = ret._fulfill;\n                    var reject = ret._reject;\n                    for (var i = 0, len = promises.length; i < len; ++i) {\n                        var val = promises[i];\n\n                        if (val === undefined && !(i in promises)) {\n                            continue;\n                        }\n\n                        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);\n                    }\n                    return ret;\n                }\n\n                Promise.race = function (promises) {\n                    return race(promises, undefined);\n                };\n\n                Promise.prototype.race = function () {\n                    return race(this, undefined);\n                };\n            };\n        }, { \"./util\": 36 }], 28: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {\n                var getDomain = Promise._getDomain;\n                var util = _dereq_(\"./util\");\n                var tryCatch = util.tryCatch;\n\n                function ReductionPromiseArray(promises, fn, initialValue, _each) {\n                    this.constructor$(promises);\n                    var domain = getDomain();\n                    this._fn = domain === null ? fn : util.domainBind(domain, fn);\n                    if (initialValue !== undefined) {\n                        initialValue = Promise.resolve(initialValue);\n                        initialValue._attachCancellationCallback(this);\n                    }\n                    this._initialValue = initialValue;\n                    this._currentCancellable = null;\n                    if (_each === INTERNAL) {\n                        this._eachValues = Array(this._length);\n                    } else if (_each === 0) {\n                        this._eachValues = null;\n                    } else {\n                        this._eachValues = undefined;\n                    }\n                    this._promise._captureStackTrace();\n                    this._init$(undefined, -5);\n                }\n                util.inherits(ReductionPromiseArray, PromiseArray);\n\n                ReductionPromiseArray.prototype._gotAccum = function (accum) {\n                    if (this._eachValues !== undefined && this._eachValues !== null && accum !== INTERNAL) {\n                        this._eachValues.push(accum);\n                    }\n                };\n\n                ReductionPromiseArray.prototype._eachComplete = function (value) {\n                    if (this._eachValues !== null) {\n                        this._eachValues.push(value);\n                    }\n                    return this._eachValues;\n                };\n\n                ReductionPromiseArray.prototype._init = function () {};\n\n                ReductionPromiseArray.prototype._resolveEmptyArray = function () {\n                    this._resolve(this._eachValues !== undefined ? this._eachValues : this._initialValue);\n                };\n\n                ReductionPromiseArray.prototype.shouldCopyValues = function () {\n                    return false;\n                };\n\n                ReductionPromiseArray.prototype._resolve = function (value) {\n                    this._promise._resolveCallback(value);\n                    this._values = null;\n                };\n\n                ReductionPromiseArray.prototype._resultCancelled = function (sender) {\n                    if (sender === this._initialValue) return this._cancel();\n                    if (this._isResolved()) return;\n                    this._resultCancelled$();\n                    if (this._currentCancellable instanceof Promise) {\n                        this._currentCancellable.cancel();\n                    }\n                    if (this._initialValue instanceof Promise) {\n                        this._initialValue.cancel();\n                    }\n                };\n\n                ReductionPromiseArray.prototype._iterate = function (values) {\n                    this._values = values;\n                    var value;\n                    var i;\n                    var length = values.length;\n                    if (this._initialValue !== undefined) {\n                        value = this._initialValue;\n                        i = 0;\n                    } else {\n                        value = Promise.resolve(values[0]);\n                        i = 1;\n                    }\n\n                    this._currentCancellable = value;\n\n                    if (!value.isRejected()) {\n                        for (; i < length; ++i) {\n                            var ctx = {\n                                accum: null,\n                                value: values[i],\n                                index: i,\n                                length: length,\n                                array: this\n                            };\n                            value = value._then(gotAccum, undefined, undefined, ctx, undefined);\n                        }\n                    }\n\n                    if (this._eachValues !== undefined) {\n                        value = value._then(this._eachComplete, undefined, undefined, this, undefined);\n                    }\n                    value._then(completed, completed, undefined, value, this);\n                };\n\n                Promise.prototype.reduce = function (fn, initialValue) {\n                    return reduce(this, fn, initialValue, null);\n                };\n\n                Promise.reduce = function (promises, fn, initialValue, _each) {\n                    return reduce(promises, fn, initialValue, _each);\n                };\n\n                function completed(valueOrReason, array) {\n                    if (this.isFulfilled()) {\n                        array._resolve(valueOrReason);\n                    } else {\n                        array._reject(valueOrReason);\n                    }\n                }\n\n                function reduce(promises, fn, initialValue, _each) {\n                    if (typeof fn !== \"function\") {\n                        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n                    }\n                    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);\n                    return array.promise();\n                }\n\n                function gotAccum(accum) {\n                    this.accum = accum;\n                    this.array._gotAccum(accum);\n                    var value = tryConvertToPromise(this.value, this.array._promise);\n                    if (value instanceof Promise) {\n                        this.array._currentCancellable = value;\n                        return value._then(gotValue, undefined, undefined, this, undefined);\n                    } else {\n                        return gotValue.call(this, value);\n                    }\n                }\n\n                function gotValue(value) {\n                    var array = this.array;\n                    var promise = array._promise;\n                    var fn = tryCatch(array._fn);\n                    promise._pushContext();\n                    var ret;\n                    if (array._eachValues !== undefined) {\n                        ret = fn.call(promise._boundValue(), value, this.index, this.length);\n                    } else {\n                        ret = fn.call(promise._boundValue(), this.accum, value, this.index, this.length);\n                    }\n                    if (ret instanceof Promise) {\n                        array._currentCancellable = ret;\n                    }\n                    var promiseCreated = promise._popContext();\n                    debug.checkForgottenReturns(ret, promiseCreated, array._eachValues !== undefined ? \"Promise.each\" : \"Promise.reduce\", promise);\n                    return ret;\n                }\n            };\n        }, { \"./util\": 36 }], 29: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            var util = _dereq_(\"./util\");\n            var schedule;\n            var noAsyncScheduler = function () {\n                throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n            };\n            var NativePromise = util.getNativePromise();\n            if (util.isNode && typeof MutationObserver === \"undefined\") {\n                var GlobalSetImmediate = global.setImmediate;\n                var ProcessNextTick = process.nextTick;\n                schedule = util.isRecentNode ? function (fn) {\n                    GlobalSetImmediate.call(global, fn);\n                } : function (fn) {\n                    ProcessNextTick.call(process, fn);\n                };\n            } else if (typeof NativePromise === \"function\" && typeof NativePromise.resolve === \"function\") {\n                var nativePromise = NativePromise.resolve();\n                schedule = function (fn) {\n                    nativePromise.then(fn);\n                };\n            } else if (typeof MutationObserver !== \"undefined\" && !(typeof window !== \"undefined\" && window.navigator && (window.navigator.standalone || window.cordova))) {\n                schedule = function () {\n                    var div = document.createElement(\"div\");\n                    var opts = { attributes: true };\n                    var toggleScheduled = false;\n                    var div2 = document.createElement(\"div\");\n                    var o2 = new MutationObserver(function () {\n                        div.classList.toggle(\"foo\");\n                        toggleScheduled = false;\n                    });\n                    o2.observe(div2, opts);\n\n                    var scheduleToggle = function () {\n                        if (toggleScheduled) return;\n                        toggleScheduled = true;\n                        div2.classList.toggle(\"foo\");\n                    };\n\n                    return function schedule(fn) {\n                        var o = new MutationObserver(function () {\n                            o.disconnect();\n                            fn();\n                        });\n                        o.observe(div, opts);\n                        scheduleToggle();\n                    };\n                }();\n            } else if (typeof setImmediate !== \"undefined\") {\n                schedule = function (fn) {\n                    setImmediate(fn);\n                };\n            } else if (typeof setTimeout !== \"undefined\") {\n                schedule = function (fn) {\n                    setTimeout(fn, 0);\n                };\n            } else {\n                schedule = noAsyncScheduler;\n            }\n            module.exports = schedule;\n        }, { \"./util\": 36 }], 30: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, PromiseArray, debug) {\n                var PromiseInspection = Promise.PromiseInspection;\n                var util = _dereq_(\"./util\");\n\n                function SettledPromiseArray(values) {\n                    this.constructor$(values);\n                }\n                util.inherits(SettledPromiseArray, PromiseArray);\n\n                SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {\n                    this._values[index] = inspection;\n                    var totalResolved = ++this._totalResolved;\n                    if (totalResolved >= this._length) {\n                        this._resolve(this._values);\n                        return true;\n                    }\n                    return false;\n                };\n\n                SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {\n                    var ret = new PromiseInspection();\n                    ret._bitField = 33554432;\n                    ret._settledValueField = value;\n                    return this._promiseResolved(index, ret);\n                };\n                SettledPromiseArray.prototype._promiseRejected = function (reason, index) {\n                    var ret = new PromiseInspection();\n                    ret._bitField = 16777216;\n                    ret._settledValueField = reason;\n                    return this._promiseResolved(index, ret);\n                };\n\n                Promise.settle = function (promises) {\n                    debug.deprecated(\".settle()\", \".reflect()\");\n                    return new SettledPromiseArray(promises).promise();\n                };\n\n                Promise.prototype.settle = function () {\n                    return Promise.settle(this);\n                };\n            };\n        }, { \"./util\": 36 }], 31: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, PromiseArray, apiRejection) {\n                var util = _dereq_(\"./util\");\n                var RangeError = _dereq_(\"./errors\").RangeError;\n                var AggregateError = _dereq_(\"./errors\").AggregateError;\n                var isArray = util.isArray;\n                var CANCELLATION = {};\n\n                function SomePromiseArray(values) {\n                    this.constructor$(values);\n                    this._howMany = 0;\n                    this._unwrap = false;\n                    this._initialized = false;\n                }\n                util.inherits(SomePromiseArray, PromiseArray);\n\n                SomePromiseArray.prototype._init = function () {\n                    if (!this._initialized) {\n                        return;\n                    }\n                    if (this._howMany === 0) {\n                        this._resolve([]);\n                        return;\n                    }\n                    this._init$(undefined, -5);\n                    var isArrayResolved = isArray(this._values);\n                    if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {\n                        this._reject(this._getRangeError(this.length()));\n                    }\n                };\n\n                SomePromiseArray.prototype.init = function () {\n                    this._initialized = true;\n                    this._init();\n                };\n\n                SomePromiseArray.prototype.setUnwrap = function () {\n                    this._unwrap = true;\n                };\n\n                SomePromiseArray.prototype.howMany = function () {\n                    return this._howMany;\n                };\n\n                SomePromiseArray.prototype.setHowMany = function (count) {\n                    this._howMany = count;\n                };\n\n                SomePromiseArray.prototype._promiseFulfilled = function (value) {\n                    this._addFulfilled(value);\n                    if (this._fulfilled() === this.howMany()) {\n                        this._values.length = this.howMany();\n                        if (this.howMany() === 1 && this._unwrap) {\n                            this._resolve(this._values[0]);\n                        } else {\n                            this._resolve(this._values);\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n                SomePromiseArray.prototype._promiseRejected = function (reason) {\n                    this._addRejected(reason);\n                    return this._checkOutcome();\n                };\n\n                SomePromiseArray.prototype._promiseCancelled = function () {\n                    if (this._values instanceof Promise || this._values == null) {\n                        return this._cancel();\n                    }\n                    this._addRejected(CANCELLATION);\n                    return this._checkOutcome();\n                };\n\n                SomePromiseArray.prototype._checkOutcome = function () {\n                    if (this.howMany() > this._canPossiblyFulfill()) {\n                        var e = new AggregateError();\n                        for (var i = this.length(); i < this._values.length; ++i) {\n                            if (this._values[i] !== CANCELLATION) {\n                                e.push(this._values[i]);\n                            }\n                        }\n                        if (e.length > 0) {\n                            this._reject(e);\n                        } else {\n                            this._cancel();\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n\n                SomePromiseArray.prototype._fulfilled = function () {\n                    return this._totalResolved;\n                };\n\n                SomePromiseArray.prototype._rejected = function () {\n                    return this._values.length - this.length();\n                };\n\n                SomePromiseArray.prototype._addRejected = function (reason) {\n                    this._values.push(reason);\n                };\n\n                SomePromiseArray.prototype._addFulfilled = function (value) {\n                    this._values[this._totalResolved++] = value;\n                };\n\n                SomePromiseArray.prototype._canPossiblyFulfill = function () {\n                    return this.length() - this._rejected();\n                };\n\n                SomePromiseArray.prototype._getRangeError = function (count) {\n                    var message = \"Input array must contain at least \" + this._howMany + \" items but contains only \" + count + \" items\";\n                    return new RangeError(message);\n                };\n\n                SomePromiseArray.prototype._resolveEmptyArray = function () {\n                    this._reject(this._getRangeError(0));\n                };\n\n                function some(promises, howMany) {\n                    if ((howMany | 0) !== howMany || howMany < 0) {\n                        return apiRejection(\"expecting a positive integer\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n                    }\n                    var ret = new SomePromiseArray(promises);\n                    var promise = ret.promise();\n                    ret.setHowMany(howMany);\n                    ret.init();\n                    return promise;\n                }\n\n                Promise.some = function (promises, howMany) {\n                    return some(promises, howMany);\n                };\n\n                Promise.prototype.some = function (howMany) {\n                    return some(this, howMany);\n                };\n\n                Promise._SomePromiseArray = SomePromiseArray;\n            };\n        }, { \"./errors\": 12, \"./util\": 36 }], 32: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise) {\n                function PromiseInspection(promise) {\n                    if (promise !== undefined) {\n                        promise = promise._target();\n                        this._bitField = promise._bitField;\n                        this._settledValueField = promise._isFateSealed() ? promise._settledValue() : undefined;\n                    } else {\n                        this._bitField = 0;\n                        this._settledValueField = undefined;\n                    }\n                }\n\n                PromiseInspection.prototype._settledValue = function () {\n                    return this._settledValueField;\n                };\n\n                var value = PromiseInspection.prototype.value = function () {\n                    if (!this.isFulfilled()) {\n                        throw new TypeError(\"cannot get fulfillment value of a non-fulfilled promise\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n                    }\n                    return this._settledValue();\n                };\n\n                var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function () {\n                    if (!this.isRejected()) {\n                        throw new TypeError(\"cannot get rejection reason of a non-rejected promise\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n                    }\n                    return this._settledValue();\n                };\n\n                var isFulfilled = PromiseInspection.prototype.isFulfilled = function () {\n                    return (this._bitField & 33554432) !== 0;\n                };\n\n                var isRejected = PromiseInspection.prototype.isRejected = function () {\n                    return (this._bitField & 16777216) !== 0;\n                };\n\n                var isPending = PromiseInspection.prototype.isPending = function () {\n                    return (this._bitField & 50397184) === 0;\n                };\n\n                var isResolved = PromiseInspection.prototype.isResolved = function () {\n                    return (this._bitField & 50331648) !== 0;\n                };\n\n                PromiseInspection.prototype.isCancelled = function () {\n                    return (this._bitField & 8454144) !== 0;\n                };\n\n                Promise.prototype.__isCancelled = function () {\n                    return (this._bitField & 65536) === 65536;\n                };\n\n                Promise.prototype._isCancelled = function () {\n                    return this._target().__isCancelled();\n                };\n\n                Promise.prototype.isCancelled = function () {\n                    return (this._target()._bitField & 8454144) !== 0;\n                };\n\n                Promise.prototype.isPending = function () {\n                    return isPending.call(this._target());\n                };\n\n                Promise.prototype.isRejected = function () {\n                    return isRejected.call(this._target());\n                };\n\n                Promise.prototype.isFulfilled = function () {\n                    return isFulfilled.call(this._target());\n                };\n\n                Promise.prototype.isResolved = function () {\n                    return isResolved.call(this._target());\n                };\n\n                Promise.prototype.value = function () {\n                    return value.call(this._target());\n                };\n\n                Promise.prototype.reason = function () {\n                    var target = this._target();\n                    target._unsetRejectionIsUnhandled();\n                    return reason.call(target);\n                };\n\n                Promise.prototype._value = function () {\n                    return this._settledValue();\n                };\n\n                Promise.prototype._reason = function () {\n                    this._unsetRejectionIsUnhandled();\n                    return this._settledValue();\n                };\n\n                Promise.PromiseInspection = PromiseInspection;\n            };\n        }, {}], 33: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, INTERNAL) {\n                var util = _dereq_(\"./util\");\n                var errorObj = util.errorObj;\n                var isObject = util.isObject;\n\n                function tryConvertToPromise(obj, context) {\n                    if (isObject(obj)) {\n                        if (obj instanceof Promise) return obj;\n                        var then = getThen(obj);\n                        if (then === errorObj) {\n                            if (context) context._pushContext();\n                            var ret = Promise.reject(then.e);\n                            if (context) context._popContext();\n                            return ret;\n                        } else if (typeof then === \"function\") {\n                            if (isAnyBluebirdPromise(obj)) {\n                                var ret = new Promise(INTERNAL);\n                                obj._then(ret._fulfill, ret._reject, undefined, ret, null);\n                                return ret;\n                            }\n                            return doThenable(obj, then, context);\n                        }\n                    }\n                    return obj;\n                }\n\n                function doGetThen(obj) {\n                    return obj.then;\n                }\n\n                function getThen(obj) {\n                    try {\n                        return doGetThen(obj);\n                    } catch (e) {\n                        errorObj.e = e;\n                        return errorObj;\n                    }\n                }\n\n                var hasProp = {}.hasOwnProperty;\n                function isAnyBluebirdPromise(obj) {\n                    try {\n                        return hasProp.call(obj, \"_promise0\");\n                    } catch (e) {\n                        return false;\n                    }\n                }\n\n                function doThenable(x, then, context) {\n                    var promise = new Promise(INTERNAL);\n                    var ret = promise;\n                    if (context) context._pushContext();\n                    promise._captureStackTrace();\n                    if (context) context._popContext();\n                    var synchronous = true;\n                    var result = util.tryCatch(then).call(x, resolve, reject);\n                    synchronous = false;\n\n                    if (promise && result === errorObj) {\n                        promise._rejectCallback(result.e, true, true);\n                        promise = null;\n                    }\n\n                    function resolve(value) {\n                        if (!promise) return;\n                        promise._resolveCallback(value);\n                        promise = null;\n                    }\n\n                    function reject(reason) {\n                        if (!promise) return;\n                        promise._rejectCallback(reason, synchronous, true);\n                        promise = null;\n                    }\n                    return ret;\n                }\n\n                return tryConvertToPromise;\n            };\n        }, { \"./util\": 36 }], 34: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, INTERNAL, debug) {\n                var util = _dereq_(\"./util\");\n                var TimeoutError = Promise.TimeoutError;\n\n                function HandleWrapper(handle) {\n                    this.handle = handle;\n                }\n\n                HandleWrapper.prototype._resultCancelled = function () {\n                    clearTimeout(this.handle);\n                };\n\n                var afterValue = function (value) {\n                    return delay(+this).thenReturn(value);\n                };\n                var delay = Promise.delay = function (ms, value) {\n                    var ret;\n                    var handle;\n                    if (value !== undefined) {\n                        ret = Promise.resolve(value)._then(afterValue, null, null, ms, undefined);\n                        if (debug.cancellation() && value instanceof Promise) {\n                            ret._setOnCancel(value);\n                        }\n                    } else {\n                        ret = new Promise(INTERNAL);\n                        handle = setTimeout(function () {\n                            ret._fulfill();\n                        }, +ms);\n                        if (debug.cancellation()) {\n                            ret._setOnCancel(new HandleWrapper(handle));\n                        }\n                        ret._captureStackTrace();\n                    }\n                    ret._setAsyncGuaranteed();\n                    return ret;\n                };\n\n                Promise.prototype.delay = function (ms) {\n                    return delay(ms, this);\n                };\n\n                var afterTimeout = function (promise, message, parent) {\n                    var err;\n                    if (typeof message !== \"string\") {\n                        if (message instanceof Error) {\n                            err = message;\n                        } else {\n                            err = new TimeoutError(\"operation timed out\");\n                        }\n                    } else {\n                        err = new TimeoutError(message);\n                    }\n                    util.markAsOriginatingFromRejection(err);\n                    promise._attachExtraTrace(err);\n                    promise._reject(err);\n\n                    if (parent != null) {\n                        parent.cancel();\n                    }\n                };\n\n                function successClear(value) {\n                    clearTimeout(this.handle);\n                    return value;\n                }\n\n                function failureClear(reason) {\n                    clearTimeout(this.handle);\n                    throw reason;\n                }\n\n                Promise.prototype.timeout = function (ms, message) {\n                    ms = +ms;\n                    var ret, parent;\n\n                    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {\n                        if (ret.isPending()) {\n                            afterTimeout(ret, message, parent);\n                        }\n                    }, ms));\n\n                    if (debug.cancellation()) {\n                        parent = this.then();\n                        ret = parent._then(successClear, failureClear, undefined, handleWrapper, undefined);\n                        ret._setOnCancel(handleWrapper);\n                    } else {\n                        ret = this._then(successClear, failureClear, undefined, handleWrapper, undefined);\n                    }\n\n                    return ret;\n                };\n            };\n        }, { \"./util\": 36 }], 35: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            module.exports = function (Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {\n                var util = _dereq_(\"./util\");\n                var TypeError = _dereq_(\"./errors\").TypeError;\n                var inherits = _dereq_(\"./util\").inherits;\n                var errorObj = util.errorObj;\n                var tryCatch = util.tryCatch;\n                var NULL = {};\n\n                function thrower(e) {\n                    setTimeout(function () {\n                        throw e;\n                    }, 0);\n                }\n\n                function castPreservingDisposable(thenable) {\n                    var maybePromise = tryConvertToPromise(thenable);\n                    if (maybePromise !== thenable && typeof thenable._isDisposable === \"function\" && typeof thenable._getDisposer === \"function\" && thenable._isDisposable()) {\n                        maybePromise._setDisposable(thenable._getDisposer());\n                    }\n                    return maybePromise;\n                }\n                function dispose(resources, inspection) {\n                    var i = 0;\n                    var len = resources.length;\n                    var ret = new Promise(INTERNAL);\n                    function iterator() {\n                        if (i >= len) return ret._fulfill();\n                        var maybePromise = castPreservingDisposable(resources[i++]);\n                        if (maybePromise instanceof Promise && maybePromise._isDisposable()) {\n                            try {\n                                maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);\n                            } catch (e) {\n                                return thrower(e);\n                            }\n                            if (maybePromise instanceof Promise) {\n                                return maybePromise._then(iterator, thrower, null, null, null);\n                            }\n                        }\n                        iterator();\n                    }\n                    iterator();\n                    return ret;\n                }\n\n                function Disposer(data, promise, context) {\n                    this._data = data;\n                    this._promise = promise;\n                    this._context = context;\n                }\n\n                Disposer.prototype.data = function () {\n                    return this._data;\n                };\n\n                Disposer.prototype.promise = function () {\n                    return this._promise;\n                };\n\n                Disposer.prototype.resource = function () {\n                    if (this.promise().isFulfilled()) {\n                        return this.promise().value();\n                    }\n                    return NULL;\n                };\n\n                Disposer.prototype.tryDispose = function (inspection) {\n                    var resource = this.resource();\n                    var context = this._context;\n                    if (context !== undefined) context._pushContext();\n                    var ret = resource !== NULL ? this.doDispose(resource, inspection) : null;\n                    if (context !== undefined) context._popContext();\n                    this._promise._unsetDisposable();\n                    this._data = null;\n                    return ret;\n                };\n\n                Disposer.isDisposer = function (d) {\n                    return d != null && typeof d.resource === \"function\" && typeof d.tryDispose === \"function\";\n                };\n\n                function FunctionDisposer(fn, promise, context) {\n                    this.constructor$(fn, promise, context);\n                }\n                inherits(FunctionDisposer, Disposer);\n\n                FunctionDisposer.prototype.doDispose = function (resource, inspection) {\n                    var fn = this.data();\n                    return fn.call(resource, resource, inspection);\n                };\n\n                function maybeUnwrapDisposer(value) {\n                    if (Disposer.isDisposer(value)) {\n                        this.resources[this.index]._setDisposable(value);\n                        return value.promise();\n                    }\n                    return value;\n                }\n\n                function ResourceList(length) {\n                    this.length = length;\n                    this.promise = null;\n                    this[length - 1] = null;\n                }\n\n                ResourceList.prototype._resultCancelled = function () {\n                    var len = this.length;\n                    for (var i = 0; i < len; ++i) {\n                        var item = this[i];\n                        if (item instanceof Promise) {\n                            item.cancel();\n                        }\n                    }\n                };\n\n                Promise.using = function () {\n                    var len = arguments.length;\n                    if (len < 2) return apiRejection(\"you must pass at least 2 arguments to Promise.using\");\n                    var fn = arguments[len - 1];\n                    if (typeof fn !== \"function\") {\n                        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n                    }\n                    var input;\n                    var spreadArgs = true;\n                    if (len === 2 && Array.isArray(arguments[0])) {\n                        input = arguments[0];\n                        len = input.length;\n                        spreadArgs = false;\n                    } else {\n                        input = arguments;\n                        len--;\n                    }\n                    var resources = new ResourceList(len);\n                    for (var i = 0; i < len; ++i) {\n                        var resource = input[i];\n                        if (Disposer.isDisposer(resource)) {\n                            var disposer = resource;\n                            resource = resource.promise();\n                            resource._setDisposable(disposer);\n                        } else {\n                            var maybePromise = tryConvertToPromise(resource);\n                            if (maybePromise instanceof Promise) {\n                                resource = maybePromise._then(maybeUnwrapDisposer, null, null, {\n                                    resources: resources,\n                                    index: i\n                                }, undefined);\n                            }\n                        }\n                        resources[i] = resource;\n                    }\n\n                    var reflectedResources = new Array(resources.length);\n                    for (var i = 0; i < reflectedResources.length; ++i) {\n                        reflectedResources[i] = Promise.resolve(resources[i]).reflect();\n                    }\n\n                    var resultPromise = Promise.all(reflectedResources).then(function (inspections) {\n                        for (var i = 0; i < inspections.length; ++i) {\n                            var inspection = inspections[i];\n                            if (inspection.isRejected()) {\n                                errorObj.e = inspection.error();\n                                return errorObj;\n                            } else if (!inspection.isFulfilled()) {\n                                resultPromise.cancel();\n                                return;\n                            }\n                            inspections[i] = inspection.value();\n                        }\n                        promise._pushContext();\n\n                        fn = tryCatch(fn);\n                        var ret = spreadArgs ? fn.apply(undefined, inspections) : fn(inspections);\n                        var promiseCreated = promise._popContext();\n                        debug.checkForgottenReturns(ret, promiseCreated, \"Promise.using\", promise);\n                        return ret;\n                    });\n\n                    var promise = resultPromise.lastly(function () {\n                        var inspection = new Promise.PromiseInspection(resultPromise);\n                        return dispose(resources, inspection);\n                    });\n                    resources.promise = promise;\n                    promise._setOnCancel(resources);\n                    return promise;\n                };\n\n                Promise.prototype._setDisposable = function (disposer) {\n                    this._bitField = this._bitField | 131072;\n                    this._disposer = disposer;\n                };\n\n                Promise.prototype._isDisposable = function () {\n                    return (this._bitField & 131072) > 0;\n                };\n\n                Promise.prototype._getDisposer = function () {\n                    return this._disposer;\n                };\n\n                Promise.prototype._unsetDisposable = function () {\n                    this._bitField = this._bitField & ~131072;\n                    this._disposer = undefined;\n                };\n\n                Promise.prototype.disposer = function (fn) {\n                    if (typeof fn === \"function\") {\n                        return new FunctionDisposer(fn, this, createContext());\n                    }\n                    throw new TypeError();\n                };\n            };\n        }, { \"./errors\": 12, \"./util\": 36 }], 36: [function (_dereq_, module, exports) {\n            \"use strict\";\n\n            var es5 = _dereq_(\"./es5\");\n            var canEvaluate = typeof navigator == \"undefined\";\n\n            var errorObj = { e: {} };\n            var tryCatchTarget;\n            var globalObject = typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : this !== undefined ? this : null;\n\n            function tryCatcher() {\n                try {\n                    var target = tryCatchTarget;\n                    tryCatchTarget = null;\n                    return target.apply(this, arguments);\n                } catch (e) {\n                    errorObj.e = e;\n                    return errorObj;\n                }\n            }\n            function tryCatch(fn) {\n                tryCatchTarget = fn;\n                return tryCatcher;\n            }\n\n            var inherits = function (Child, Parent) {\n                var hasProp = {}.hasOwnProperty;\n\n                function T() {\n                    this.constructor = Child;\n                    this.constructor$ = Parent;\n                    for (var propertyName in Parent.prototype) {\n                        if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== \"$\") {\n                            this[propertyName + \"$\"] = Parent.prototype[propertyName];\n                        }\n                    }\n                }\n                T.prototype = Parent.prototype;\n                Child.prototype = new T();\n                return Child.prototype;\n            };\n\n            function isPrimitive(val) {\n                return val == null || val === true || val === false || typeof val === \"string\" || typeof val === \"number\";\n            }\n\n            function isObject(value) {\n                return typeof value === \"function\" || typeof value === \"object\" && value !== null;\n            }\n\n            function maybeWrapAsError(maybeError) {\n                if (!isPrimitive(maybeError)) return maybeError;\n\n                return new Error(safeToString(maybeError));\n            }\n\n            function withAppended(target, appendee) {\n                var len = target.length;\n                var ret = new Array(len + 1);\n                var i;\n                for (i = 0; i < len; ++i) {\n                    ret[i] = target[i];\n                }\n                ret[i] = appendee;\n                return ret;\n            }\n\n            function getDataPropertyOrDefault(obj, key, defaultValue) {\n                if (es5.isES5) {\n                    var desc = Object.getOwnPropertyDescriptor(obj, key);\n\n                    if (desc != null) {\n                        return desc.get == null && desc.set == null ? desc.value : defaultValue;\n                    }\n                } else {\n                    return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;\n                }\n            }\n\n            function notEnumerableProp(obj, name, value) {\n                if (isPrimitive(obj)) return obj;\n                var descriptor = {\n                    value: value,\n                    configurable: true,\n                    enumerable: false,\n                    writable: true\n                };\n                es5.defineProperty(obj, name, descriptor);\n                return obj;\n            }\n\n            function thrower(r) {\n                throw r;\n            }\n\n            var inheritedDataKeys = function () {\n                var excludedPrototypes = [Array.prototype, Object.prototype, Function.prototype];\n\n                var isExcludedProto = function (val) {\n                    for (var i = 0; i < excludedPrototypes.length; ++i) {\n                        if (excludedPrototypes[i] === val) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n\n                if (es5.isES5) {\n                    var getKeys = Object.getOwnPropertyNames;\n                    return function (obj) {\n                        var ret = [];\n                        var visitedKeys = Object.create(null);\n                        while (obj != null && !isExcludedProto(obj)) {\n                            var keys;\n                            try {\n                                keys = getKeys(obj);\n                            } catch (e) {\n                                return ret;\n                            }\n                            for (var i = 0; i < keys.length; ++i) {\n                                var key = keys[i];\n                                if (visitedKeys[key]) continue;\n                                visitedKeys[key] = true;\n                                var desc = Object.getOwnPropertyDescriptor(obj, key);\n                                if (desc != null && desc.get == null && desc.set == null) {\n                                    ret.push(key);\n                                }\n                            }\n                            obj = es5.getPrototypeOf(obj);\n                        }\n                        return ret;\n                    };\n                } else {\n                    var hasProp = {}.hasOwnProperty;\n                    return function (obj) {\n                        if (isExcludedProto(obj)) return [];\n                        var ret = [];\n\n                        /*jshint forin:false */\n                        enumeration: for (var key in obj) {\n                            if (hasProp.call(obj, key)) {\n                                ret.push(key);\n                            } else {\n                                for (var i = 0; i < excludedPrototypes.length; ++i) {\n                                    if (hasProp.call(excludedPrototypes[i], key)) {\n                                        continue enumeration;\n                                    }\n                                }\n                                ret.push(key);\n                            }\n                        }\n                        return ret;\n                    };\n                }\n            }();\n\n            var thisAssignmentPattern = /this\\s*\\.\\s*\\S+\\s*=/;\n            function isClass(fn) {\n                try {\n                    if (typeof fn === \"function\") {\n                        var keys = es5.names(fn.prototype);\n\n                        var hasMethods = es5.isES5 && keys.length > 1;\n                        var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === \"constructor\");\n                        var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + \"\") && es5.names(fn).length > 0;\n\n                        if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {\n                            return true;\n                        }\n                    }\n                    return false;\n                } catch (e) {\n                    return false;\n                }\n            }\n\n            function toFastProperties(obj) {\n                /*jshint -W027,-W055,-W031*/\n                function FakeConstructor() {}\n                FakeConstructor.prototype = obj;\n                var l = 8;\n                while (l--) new FakeConstructor();\n                return obj;\n                eval(obj);\n            }\n\n            var rident = /^[a-z$_][a-z$_0-9]*$/i;\n            function isIdentifier(str) {\n                return rident.test(str);\n            }\n\n            function filledRange(count, prefix, suffix) {\n                var ret = new Array(count);\n                for (var i = 0; i < count; ++i) {\n                    ret[i] = prefix + i + suffix;\n                }\n                return ret;\n            }\n\n            function safeToString(obj) {\n                try {\n                    return obj + \"\";\n                } catch (e) {\n                    return \"[no string representation]\";\n                }\n            }\n\n            function isError(obj) {\n                return obj instanceof Error || obj !== null && typeof obj === \"object\" && typeof obj.message === \"string\" && typeof obj.name === \"string\";\n            }\n\n            function markAsOriginatingFromRejection(e) {\n                try {\n                    notEnumerableProp(e, \"isOperational\", true);\n                } catch (ignore) {}\n            }\n\n            function originatesFromRejection(e) {\n                if (e == null) return false;\n                return e instanceof Error[\"__BluebirdErrorTypes__\"].OperationalError || e[\"isOperational\"] === true;\n            }\n\n            function canAttachTrace(obj) {\n                return isError(obj) && es5.propertyIsWritable(obj, \"stack\");\n            }\n\n            var ensureErrorObject = function () {\n                if (!(\"stack\" in new Error())) {\n                    return function (value) {\n                        if (canAttachTrace(value)) return value;\n                        try {\n                            throw new Error(safeToString(value));\n                        } catch (err) {\n                            return err;\n                        }\n                    };\n                } else {\n                    return function (value) {\n                        if (canAttachTrace(value)) return value;\n                        return new Error(safeToString(value));\n                    };\n                }\n            }();\n\n            function classString(obj) {\n                return {}.toString.call(obj);\n            }\n\n            function copyDescriptors(from, to, filter) {\n                var keys = es5.names(from);\n                for (var i = 0; i < keys.length; ++i) {\n                    var key = keys[i];\n                    if (filter(key)) {\n                        try {\n                            es5.defineProperty(to, key, es5.getDescriptor(from, key));\n                        } catch (ignore) {}\n                    }\n                }\n            }\n\n            var asArray = function (v) {\n                if (es5.isArray(v)) {\n                    return v;\n                }\n                return null;\n            };\n\n            if (typeof Symbol !== \"undefined\" && Symbol.iterator) {\n                var ArrayFrom = typeof Array.from === \"function\" ? function (v) {\n                    return Array.from(v);\n                } : function (v) {\n                    var ret = [];\n                    var it = v[Symbol.iterator]();\n                    var itResult;\n                    while (!(itResult = it.next()).done) {\n                        ret.push(itResult.value);\n                    }\n                    return ret;\n                };\n\n                asArray = function (v) {\n                    if (es5.isArray(v)) {\n                        return v;\n                    } else if (v != null && typeof v[Symbol.iterator] === \"function\") {\n                        return ArrayFrom(v);\n                    }\n                    return null;\n                };\n            }\n\n            var isNode = typeof process !== \"undefined\" && classString(process).toLowerCase() === \"[object process]\";\n\n            var hasEnvVariables = typeof process !== \"undefined\" && typeof process.env !== \"undefined\";\n\n            function env(key) {\n                return hasEnvVariables ? process.env[key] : undefined;\n            }\n\n            function getNativePromise() {\n                if (typeof Promise === \"function\") {\n                    try {\n                        var promise = new Promise(function () {});\n                        if ({}.toString.call(promise) === \"[object Promise]\") {\n                            return Promise;\n                        }\n                    } catch (e) {}\n                }\n            }\n\n            function domainBind(self, cb) {\n                return self.bind(cb);\n            }\n\n            var ret = {\n                isClass: isClass,\n                isIdentifier: isIdentifier,\n                inheritedDataKeys: inheritedDataKeys,\n                getDataPropertyOrDefault: getDataPropertyOrDefault,\n                thrower: thrower,\n                isArray: es5.isArray,\n                asArray: asArray,\n                notEnumerableProp: notEnumerableProp,\n                isPrimitive: isPrimitive,\n                isObject: isObject,\n                isError: isError,\n                canEvaluate: canEvaluate,\n                errorObj: errorObj,\n                tryCatch: tryCatch,\n                inherits: inherits,\n                withAppended: withAppended,\n                maybeWrapAsError: maybeWrapAsError,\n                toFastProperties: toFastProperties,\n                filledRange: filledRange,\n                toString: safeToString,\n                canAttachTrace: canAttachTrace,\n                ensureErrorObject: ensureErrorObject,\n                originatesFromRejection: originatesFromRejection,\n                markAsOriginatingFromRejection: markAsOriginatingFromRejection,\n                classString: classString,\n                copyDescriptors: copyDescriptors,\n                hasDevTools: typeof chrome !== \"undefined\" && chrome && typeof chrome.loadTimes === \"function\",\n                isNode: isNode,\n                hasEnvVariables: hasEnvVariables,\n                env: env,\n                global: globalObject,\n                getNativePromise: getNativePromise,\n                domainBind: domainBind\n            };\n            ret.isRecentNode = ret.isNode && function () {\n                var version = process.versions.node.split(\".\").map(Number);\n                return version[0] === 0 && version[1] > 10 || version[0] > 0;\n            }();\n\n            if (ret.isNode) ret.toFastProperties(process);\n\n            try {\n                throw new Error();\n            } catch (e) {\n                ret.lastLineError = e;\n            }\n            module.exports = ret;\n        }, { \"./es5\": 13 }] }, {}, [4])(4);\n});;if (typeof window !== 'undefined' && window !== null) {\n    window.P = window.Promise;\n} else if (typeof self !== 'undefined' && self !== null) {\n    self.P = self.Promise;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack://jo/./node_modules/bluebird/js/browser/bluebird.js?");

/***/ }),

/***/ "./node_modules/node-libs-browser/mock/empty.js":
/*!******************************************************!*\
  !*** ./node_modules/node-libs-browser/mock/empty.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack://jo/./node_modules/node-libs-browser/mock/empty.js?");

/***/ }),

/***/ "./node_modules/os-browserify/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/os-browserify/browser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.endianness = function () {\n    return 'LE';\n};\n\nexports.hostname = function () {\n    if (typeof location !== 'undefined') {\n        return location.hostname;\n    } else return '';\n};\n\nexports.loadavg = function () {\n    return [];\n};\n\nexports.uptime = function () {\n    return 0;\n};\n\nexports.freemem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.totalmem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.cpus = function () {\n    return [];\n};\n\nexports.type = function () {\n    return 'Browser';\n};\n\nexports.release = function () {\n    if (typeof navigator !== 'undefined') {\n        return navigator.appVersion;\n    }\n    return '';\n};\n\nexports.networkInterfaces = exports.getNetworkInterfaces = function () {\n    return {};\n};\n\nexports.arch = function () {\n    return 'javascript';\n};\n\nexports.platform = function () {\n    return 'browser';\n};\n\nexports.tmpdir = exports.tmpDir = function () {\n    return '/tmp';\n};\n\nexports.EOL = '\\n';\n\nexports.homedir = function () {\n    return '/';\n};\n\n//# sourceURL=webpack://jo/./node_modules/os-browserify/browser.js?");

/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function (filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function () {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = i >= 0 ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function (path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function (p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function (path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function () {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function (p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n// path.relative(from, to)\n// posix version\nexports.relative = function (from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\nexports.basename = function (path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  return splitPath(path)[3];\n};\n\nfunction filter(xs, f) {\n  if (xs.filter) return xs.filter(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    if (f(xs[i], i, xs)) res.push(xs[i]);\n  }\n  return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {\n  return str.substr(start, len);\n} : function (str, start, len) {\n  if (start < 0) start = str.length + start;\n  return str.substr(start, len);\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://jo/./node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n    return [];\n};\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n    return '/';\n};\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function () {\n    return 0;\n};\n\n//# sourceURL=webpack://jo/./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n        // Callback can either be a function or a string\n        if (typeof callback !== \"function\") {\n            callback = new Function(\"\" + callback);\n        }\n        // Copy function arguments\n        var args = new Array(arguments.length - 1);\n        for (var i = 0; i < args.length; i++) {\n            args[i] = arguments[i + 1];\n        }\n        // Store and register the task\n        var task = { callback: callback, args: args };\n        tasksByHandle[nextHandle] = task;\n        registerImmediate(nextHandle);\n        return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n            case 0:\n                callback();\n                break;\n            case 1:\n                callback(args[0]);\n                break;\n            case 2:\n                callback(args[0], args[1]);\n                break;\n            case 3:\n                callback(args[0], args[1], args[2]);\n                break;\n            default:\n                callback.apply(undefined, args);\n                break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function (handle) {\n            process.nextTick(function () {\n                runIfPresent(handle);\n            });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function () {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function (event) {\n            if (event.source === global && typeof event.data === \"string\" && event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function (handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function (event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function (handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function (handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function (handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n})(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://jo/./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function () {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function () {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout = exports.clearInterval = function (timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function () {};\nTimeout.prototype.close = function () {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function (item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function (item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout) item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmeidate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = typeof self !== \"undefined\" && self.setImmediate || typeof global !== \"undefined\" && global.setImmediate || this && this.setImmediate;\nexports.clearImmediate = typeof self !== \"undefined\" && self.clearImmediate || typeof global !== \"undefined\" && global.clearImmediate || this && this.clearImmediate;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://jo/./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/underscore/underscore.js":
/*!***********************************************!*\
  !*** ./node_modules/underscore/underscore.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind,\n    nativeCreate       = Object.create;\n\n  // Naked function reference for surrogate-prototype-swapping.\n  var Ctor = function(){};\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object.\n  if (true) {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {}\n\n  // Current version.\n  _.VERSION = '1.8.3';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      case 2: return function(value, other) {\n        return func.call(context, value, other);\n      };\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  // A mostly-internal function to generate callbacks that can be applied\n  // to each element in a collection, returning the desired result  either\n  // identity, an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n    if (_.isObject(value)) return _.matcher(value);\n    return _.property(value);\n  };\n  _.iteratee = function(value, context) {\n    return cb(value, context, Infinity);\n  };\n\n  // An internal function for creating assigner functions.\n  var createAssigner = function(keysFunc, undefinedOnly) {\n    return function(obj) {\n      var length = arguments.length;\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  };\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null;\n    return result;\n  };\n\n  var property = function(key) {\n    return function(obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  };\n\n  // Helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n  var getLength = property('length');\n  var isArrayLike = function(collection) {\n    var length = getLength(collection);\n    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function(obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Create a reducing function iterating left or right.\n  function createReduce(dir) {\n    // Optimized iterator function as using arguments.length\n    // in the main function will deoptimize the, see #1991.\n    function iterator(obj, iteratee, memo, keys, index, length) {\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = keys ? keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    }\n\n    return function(obj, iteratee, memo, context) {\n      iteratee = optimizeCb(iteratee, context, 4);\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      // Determine the initial value if none is provided.\n      if (arguments.length < 3) {\n        memo = obj[keys ? keys[index] : index];\n        index += dir;\n      }\n      return iterator(obj, iteratee, memo, keys, index, length);\n    };\n  }\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = createReduce(-1);\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var key;\n    if (isArrayLike(obj)) {\n      key = _.findIndex(obj, predicate, context);\n    } else {\n      key = _.findKey(obj, predicate, context);\n    }\n    if (key !== void 0 && key !== -1) return obj[key];\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    _.each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, _.negate(cb(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given item (using `===`).\n  // Aliased as `includes` and `include`.\n  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {\n    if (!isArrayLike(obj)) obj = _.values(obj);\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n    return _.indexOf(obj, item, fromIndex) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      var func = isFunc ? method : value[method];\n      return func == null ? func : func.apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matcher(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matcher(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).\n  _.shuffle = function(obj) {\n    var set = isArrayLike(obj) ? obj : _.values(obj);\n    var length = set.length;\n    var shuffled = Array(length);\n    for (var index = 0, rand; index < length; index++) {\n      rand = _.random(0, index);\n      if (rand !== index) shuffled[index] = shuffled[rand];\n      shuffled[rand] = set[index];\n    }\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iteratee(value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iteratee, context) {\n      var result = {};\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (isArrayLike(obj)) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var pass = [], fail = [];\n    _.each(obj, function(value, key, obj) {\n      (predicate(value, key, obj) ? pass : fail).push(value);\n    });\n    return [pass, fail];\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[0];\n    return _.initial(array, array.length - n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[array.length - 1];\n    return _.rest(array, Math.max(0, array.length - n));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, strict, startIndex) {\n    var output = [], idx = 0;\n    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n        //flatten current level of array or arguments object\n        if (!shallow) value = flatten(value, shallow, strict);\n        var j = 0, len = value.length;\n        output.length += len;\n        while (j < len) {\n          output[idx++] = value[j++];\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, false);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!_.contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!_.contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(flatten(arguments, true, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      for (var j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = flatten(arguments, true, true, 1);\n    return _.filter(array, function(value){\n      return !_.contains(rest, value);\n    });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    return _.unzip(arguments);\n  };\n\n  // Complement of _.zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices\n  _.unzip = function(array) {\n    var length = array && _.max(array, getLength).length || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = _.pluck(array, index);\n    }\n    return result;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    var result = {};\n    for (var i = 0, length = getLength(list); i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Generator function to create the findIndex and findLastIndex functions\n  function createPredicateIndexFinder(dir) {\n    return function(array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = getLength(array);\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  }\n\n  // Returns the first index on an array-like that passes a predicate test\n  _.findIndex = createPredicateIndexFinder(1);\n  _.findLastIndex = createPredicateIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = getLength(array);\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  };\n\n  // Generator function to create the indexOf and lastIndexOf functions\n  function createIndexFinder(dir, predicateFind, sortedIndex) {\n    return function(array, item, idx) {\n      var i = 0, length = getLength(array);\n      if (typeof idx == 'number') {\n        if (dir > 0) {\n            i = idx >= 0 ? idx : Math.max(idx + length, i);\n        } else {\n            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n        }\n      } else if (sortedIndex && idx && length) {\n        idx = sortedIndex(array, item);\n        return array[idx] === item ? idx : -1;\n      }\n      if (item !== item) {\n        idx = predicateFind(slice.call(array, i, length), _.isNaN);\n        return idx >= 0 ? idx + i : -1;\n      }\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n        if (array[idx] === item) return idx;\n      }\n      return -1;\n    };\n  }\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (stop == null) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = step || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Determines whether to execute a function as a constructor\n  // or a normal function with the provided arguments\n  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (_.isObject(result)) return result;\n    return self;\n  };\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    var args = slice.call(arguments, 2);\n    var bound = function() {\n      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));\n    };\n    return bound;\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    var bound = function() {\n      var position = 0, length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var i, length = arguments.length, key;\n    if (length <= 1) throw new Error('bindAll must be passed function names');\n    for (i = 1; i < length; i++) {\n      key = arguments[i];\n      obj[key] = _.bind(obj[key], obj);\n    }\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){\n      return func.apply(null, args);\n    }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = _.partial(_.delay, _, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n\n      if (last < wait && last >= 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed on and after the Nth call.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed up to (but not including) the Nth call.\n  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  // Object Functions\n  // ----------------\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  function collectNonEnumProps(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  }\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve all the property names of an object.\n  _.allKeys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Returns the results of applying the iteratee to each element of the object\n  // In contrast to _.map it returns an object\n  _.mapObject = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys =  _.keys(obj),\n          length = keys.length,\n          results = {},\n          currentKey;\n      for (var index = 0; index < length; index++) {\n        currentKey = keys[index];\n        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n      }\n      return results;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = createAssigner(_.allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in object(s)\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  _.extendOwn = _.assign = createAssigner(_.keys);\n\n  // Returns the first key on an object that passes a predicate test\n  _.findKey = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = _.keys(obj), key;\n    for (var i = 0, length = keys.length; i < length; i++) {\n      key = keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(object, oiteratee, context) {\n    var result = {}, obj = object, iteratee, keys;\n    if (obj == null) return result;\n    if (_.isFunction(oiteratee)) {\n      keys = _.allKeys(obj);\n      iteratee = optimizeCb(oiteratee, context);\n    } else {\n      keys = flatten(arguments, false, false, 1);\n      iteratee = function(value, key, obj) { return key in obj; };\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj, iteratee, context) {\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n    } else {\n      var keys = _.map(flatten(arguments, false, false, 1), String);\n      iteratee = function(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = createAssigner(_.allKeys, true);\n\n  // Creates an object that inherits from the given prototype object.\n  // If additional properties are provided then they will be added to the\n  // created object.\n  _.create = function(prototype, props) {\n    var result = baseCreate(prototype);\n    if (props) _.extendOwn(result, props);\n    return result;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  _.isMatch = function(object, attrs) {\n    var keys = _.keys(attrs), length = keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  };\n\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays) {\n      if (typeof a != 'object' || typeof b != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n                               _.isFunction(bCtor) && bCtor instanceof bCtor)\n                          && ('constructor' in a && 'constructor' in b)) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a), key;\n      length = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (_.keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = keys[length];\n        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n    return _.keys(obj).length === 0;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return _.has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n  // IE 11 (#1621), and in Safari 8 (#1929).\n  if (typeof /./ != 'function' && typeof Int8Array != 'object') {\n    _.isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj !== +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return obj != null && hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Predicate-generating functions. Often useful outside of Underscore.\n  _.constant = function(value) {\n    return function() {\n      return value;\n    };\n  };\n\n  _.noop = function(){};\n\n  _.property = property;\n\n  // Generates a function for a given object that returns a given property.\n  _.propertyOf = function(obj) {\n    return obj == null ? function(){} : function(key) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  _.matcher = _.matches = function(attrs) {\n    attrs = _.extendOwn({}, attrs);\n    return function(obj) {\n      return _.isMatch(obj, attrs);\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n   // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property, fallback) {\n    var value = object == null ? void 0 : object[property];\n    if (value === void 0) {\n      value = fallback;\n    }\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escaper, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offest.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function(obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(instance, obj) {\n    return instance._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return result(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxy for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\n  _.prototype.toString = function() {\n    return '' + this._wrapped;\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return _;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n}.call(this));\n\n\n//# sourceURL=webpack://jo/./node_modules/underscore/underscore.js?");

/***/ }),

/***/ "./node_modules/underscore/underscore.js-exposed":
/*!*******************************************************!*\
  !*** ./node_modules/underscore/underscore.js-exposed ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {module.exports = global[\"_\"] = __webpack_require__(/*! -!./underscore.js */ \"./node_modules/underscore/underscore.js\");\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://jo/./node_modules/underscore/underscore.js-exposed?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n//# sourceURL=webpack://jo/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/browserEnv.js":
/*!***************************!*\
  !*** ./src/browserEnv.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("let resultsPath = 'results';\nlet currentTest;\n\nfunction startRun(lResultsPath) {\n    if (lResultsPath) resultsPath = lResultsPath;\n    //ENH: simplify integration with react app\n    justOutputUIRender(true);\n}\n\nfunction startTest(test) {\n    currentTest = test;\n}\n\nfunction writeTmpResult(currentTestOutput) {\n    //do nothing\n    //ENH: write file via a chrome plugin?\n}\n\nfunction getAcceptedResult() {\n    const acceptedFilePath = getAcceptedResultPath();\n    const url = acceptedFilePath + '?' + Math.random(); //add a random param to the url so that the browser doesn't use cached results\n    return _ajax(url);\n}\n\nfunction getAcceptedResultPath() {\n    return resultsPath + '/' + currentTest.filename + '.txt';\n}\n\nfunction handleResult(result) {\n    window.handleTestResult(result, currentTest);\n}\n\nfunction list(test) {\n    console.log('test:', test.filename);\n}\n\nfunction _ajax(url) {\n    return new Promise(function (resolve, reject) {\n        var request = new XMLHttpRequest();\n\n        function onload() {\n            if (request.status >= 200 && request.status < 400) {\n                var result = request.response || request.responseText || request.responseXML;\n                resolve(result);\n            } else {\n                var error = new Error(\"Status code was \" + request.status);\n                error.code = request.status;\n                error.responseText = request.responseText;\n                reject(error);\n            }\n        }\n\n        function onerror() {\n            reject(new Error(\"Can't XHR \" + JSON.stringify(url)));\n        }\n\n        try {\n            request.open(\"GET\", url, true);\n            request.onreadystatechange = function () {\n                if (request.readyState === 4) {\n                    onload();\n                }\n            };\n            request.onload = request.load = onload;\n            request.onerror = request.error = onerror;\n            request.send();\n        } catch (exception) {\n            reject(exception);\n        }\n    });\n}\n\nmodule.exports = {\n    startRun,\n    startTest,\n    writeTmpResult,\n    getAcceptedResultPath,\n    getAcceptedResult,\n    handleResult,\n    list\n};\n\n//# sourceURL=webpack://jo/./src/browserEnv.js?");

/***/ }),

/***/ "./src/diff.js":
/*!*********************!*\
  !*** ./src/diff.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//Adapted from https://github.com/Slava/diff.js\n\n\n// Refer to http://www.xmailserver.org/diff2.pdf\n\n// Longest Common Subsequence\n// @param A - sequence of atoms - Array\n// @param B - sequence of atoms - Array\n// @param equals - optional comparator of atoms - returns true or false,\n//                 if not specified, triple equals operator is used\n// @returns Array - sequence of atoms, one of LCSs, edit script from A to B\nvar LCS = function (A, B, /* optional */equals) {\n  // We just compare atoms with default equals operator by default\n  if (equals === undefined) equals = function (a, b) {\n    return a === b;\n  };\n\n  // NOTE: all intervals from now on are both sides inclusive\n  // Get the points in Edit Graph, one of the LCS paths goes through.\n  // The points are located on the same diagonal and represent the middle\n  // snake ([D/2] out of D+1) in the optimal edit path in edit graph.\n  // @param startA, endA - substring of A we are working on\n  // @param startB, endB - substring of B we are working on\n  // @returns Array - [\n  //                   [x, y], - beginning of the middle snake\n  //                   [u, v], - end of the middle snake\n  //                    D,     - optimal edit distance\n  //                    LCS ]  - length of LCS\n  var findMidSnake = function (startA, endA, startB, endB) {\n    var N = endA - startA + 1;\n    var M = endB - startB + 1;\n    var Max = N + M;\n    var Delta = N - M;\n    var halfMaxCeil = (Max + 1) / 2 | 0;\n\n    var foundOverlap = false;\n    var overlap = null;\n\n    // Maps -Max .. 0 .. +Max, diagonal index to endpoints for furthest reaching\n    // D-path on current iteration.\n    var V = {};\n    // Same but for reversed paths.\n    var U = {};\n\n    // Special case for the base case, D = 0, k = 0, x = y = 0\n    V[1] = 0;\n    // Special case for the base case reversed, D = 0, k = 0, x = N, y = M\n    U[Delta - 1] = N;\n\n    // Iterate over each possible length of edit script\n    for (var D = 0; D <= halfMaxCeil; D++) {\n      // Iterate over each diagonal\n      for (var k = -D; k <= D && !overlap; k += 2) {\n        // Positions in sequences A and B of furthest going D-path on diagonal k.\n        var x, y;\n\n        // Choose from each diagonal we extend\n        if (k === -D || k !== D && V[k - 1] < V[k + 1])\n          // Extending path one point down, that's why x doesn't change, y\n          // increases implicitly\n          x = V[k + 1];else\n          // Extending path one point to the right, x increases\n          x = V[k - 1] + 1;\n\n        // We can calculate the y out of x and diagonal index.\n        y = x - k;\n\n        if (isNaN(y) || x > N || y > M) continue;\n\n        var xx = x;\n        // Try to extend the D-path with diagonal paths. Possible only if atoms\n        // A_x match B_y\n        while (x < N && y < M // if there are atoms to compare\n        && equals(A[startA + x], B[startB + y])) {\n          x++;y++;\n        }\n\n        // We can safely update diagonal k, since on every iteration we consider\n        // only even or only odd diagonals and the result of one depends only on\n        // diagonals of different iteration.\n        V[k] = x;\n\n        // Check feasibility, Delta is checked for being odd.\n        if ((Delta & 1) === 1 && inRange(k, Delta - (D - 1), Delta + (D - 1)))\n          // Forward D-path can overlap with reversed D-1-path\n          if (V[k] >= U[k])\n            // Found an overlap, the middle snake, convert X-components to dots\n            overlap = _.map([xx, x], toPoint, k); // XXX ES5\n      }\n\n      if (overlap) var SES = D * 2 - 1;\n\n      // Iterate over each diagonal for reversed case\n      for (var k = -D; k <= D && !overlap; k += 2) {\n        // The real diagonal we are looking for is k + Delta\n        var K = k + Delta;\n        var x, y;\n        if (k === D || k !== -D && U[K - 1] < U[K + 1]) x = U[K - 1];else x = U[K + 1] - 1;\n\n        y = x - K;\n        if (isNaN(y) || x < 0 || y < 0) continue;\n        var xx = x;\n        while (x > 0 && y > 0 && equals(A[startA + x - 1], B[startB + y - 1])) {\n          x--;y--;\n        }\n        U[K] = x;\n\n        if (Delta % 2 === 0 && inRange(K, -D, D)) if (U[K] <= V[K]) overlap = _.map([x, xx], toPoint, K); // XXX ES5\n      }\n\n      if (overlap) {\n        SES = SES || D * 2;\n        // Remember we had offset of each sequence?\n        for (var i = 0; i < 2; i++) for (var j = 0; j < 2; j++) overlap[i][j] += [startA, startB][j] - i;\n        return overlap.concat([SES, (Max - SES) / 2]);\n      }\n    }\n  };\n\n  var lcsAtoms = [];\n  var lcs = function (startA, endA, startB, endB) {\n    var N = endA - startA + 1;\n    var M = endB - startB + 1;\n\n    if (N > 0 && M > 0) {\n      var middleSnake = findMidSnake(startA, endA, startB, endB);\n      // A[x;u] == B[y,v] and is part of LCS\n      var x = middleSnake[0][0],\n          y = middleSnake[0][1];\n      var u = middleSnake[1][0],\n          v = middleSnake[1][1];\n      var D = middleSnake[2];\n\n      if (D > 1) {\n        lcs(startA, x - 1, startB, y - 1);\n        if (x <= u) {\n          [].push.apply(lcsAtoms, A.slice(x, u + 1));\n        }\n        lcs(u + 1, endA, v + 1, endB);\n      } else if (M > N) [].push.apply(lcsAtoms, A.slice(startA, endA + 1));else [].push.apply(lcsAtoms, B.slice(startB, endB + 1));\n    }\n  };\n\n  lcs(0, A.length - 1, 0, B.length - 1);\n  return lcsAtoms;\n};\n\n// Helpers\nvar inRange = function (x, l, r) {\n  return l <= x && x <= r || r <= x && x <= l;\n};\n\n// Takes X-component as argument, diagonal as context,\n// returns array-pair of form x, y\nvar toPoint = function (x) {\n  return [x, x - this]; // XXX context is not the best way to pass diagonal\n};\n\n// Wrappers\nLCS.StringLCS = function (A, B) {\n  return LCS(A.split(''), B.split('')).join('');\n};\n\n// Exports\nif (true) module.exports = LCS;\n\n// Diff sequence\n// @param A - sequence of atoms - Array\n// @param B - sequence of atoms - Array\n// @param equals - optional comparator of atoms - returns true or false,\n//                 if not specified, triple equals operator is used\n// @returns Array - sequence of objects in a form of:\n//   - operation: one of \"none\", \"add\", \"delete\"\n//   - atom: the atom found in either A or B\n// Applying operations from diff sequence you should be able to transform A to B\n\n\nconst _ = __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore.js-exposed\");\n\nvar diff = function (A, B, equals) {\n  // We just compare atoms with default equals operator by default\n  if (equals === undefined) equals = function (a, b) {\n    return a === b;\n  };\n\n  var diff = [];\n  var i = 0,\n      j = 0;\n  var N = A.length,\n      M = B.length,\n      K = 0;\n\n  while (i < N && j < M && equals(A[i], B[j])) i++, j++;\n\n  while (i < N && j < M && equals(A[N - 1], B[M - 1])) N--, M--, K++;\n\n  _.map([].push.apply(diff, A.slice(0, i)), function (atom) {\n    return { operation: \"none\", atom: atom };\n  });\n\n  var lcs = LCS(A.slice(i, N), B.slice(j, M), equals);\n\n  for (var k = 0; k < lcs.length; k++) {\n    var atom = lcs[k];\n    var ni = customIndexOf.call(A, atom, i, equals);\n    var nj = customIndexOf.call(B, atom, j, equals);\n\n    // XXX ES5 map\n    // Delete unmatched atoms from A\n    [].push.apply(diff, _.map(A.slice(i, ni), function (atom) {\n      return { operation: \"delete\", atom: atom };\n    }));\n\n    // Add unmatched atoms from B\n    [].push.apply(diff, _.map(B.slice(j, nj), function (atom) {\n      return { operation: \"add\", atom: atom };\n    }));\n\n    // Add the atom found in both sequences\n    diff.push({ operation: \"none\", atom: atom });\n\n    i = ni + 1;\n    j = nj + 1;\n  }\n\n  // Don't forget about the rest\n\n  [].push.apply(diff, _.map(A.slice(i, N), function (atom) {\n    return { operation: \"delete\", atom: atom };\n  }));\n\n  [].push.apply(diff, _.map(B.slice(j, M), function (atom) {\n    return { operation: \"add\", atom: atom };\n  }));\n\n  [].push.apply(diff, _.map(A.slice(N, N + K), function (atom) {\n    return { operation: \"none\", atom: atom };\n  }));\n\n  return diff;\n};\n\n// Accepts custom comparator\nvar customIndexOf = function (item, start, equals) {\n  var arr = this;\n  for (var i = start; i < arr.length; i++) if (equals(item, arr[i])) return i;\n  return -1;\n};\n\n// Exports\nmodule.exports = diff;\n\n//# sourceURL=webpack://jo/./src/diff.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {\nconst testsEnv = typeof window == 'undefined' ? __webpack_require__(/*! ./nodeEnv */ \"./src/nodeEnv.js\") : __webpack_require__(/*! ./browserEnv */ \"./src/browserEnv.js\");\nconst diff = __webpack_require__(/*! ./diff */ \"./src/diff.js\");\nconst _ = __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore.js-exposed\");\nconst Promise = __webpack_require__(/*! bluebird */ \"./node_modules/bluebird/js/browser/bluebird.js\");\n\nconst tests = [];\nlet currentSuite;\nlet currentTest;\nlet cancelRun = false;\n/**\r\n * Declares a test suite\r\n * @param  {string} name        Name of test suite\r\n * @param  {function} [tests]   Tests to run. If not specified, all tests declared until next call will be considered part of this suite\r\n */\nfunction suite(name, tests) {\n    currentSuite = name;\n    if (tests) {\n        tests();\n        currentSuite = undefined;\n    }\n}\n\n/**\r\n * Declares a test\r\n * @param  {string} name        Name of test\r\n * @param  {function} testFunc  Function to execute as part of test\r\n */\nfunction test(name, testFunc) {\n    const fullName = currentSuite ? currentSuite + ' ' + name : name;\n    tests.push({\n        name: fullName,\n        testFunc,\n        suite: currentSuite,\n        filename: fullName.replace(/[^a-z0-9]/gi, '_')\n    });\n}\n\nfunction output() {\n    var args = _.map(arguments, function (value) {\n        return typeof value == 'string' ? value : _stringify(value);\n    });\n    currentTest.output += args.join(' ');\n    currentTest.output += '\\n';\n}\n\nfunction section(name, test) {\n    if (typeof test == 'function') {\n        output('\\n***', name);\n        test();\n    } else {\n        output('\\n***', ...arguments);\n    }\n}\n\nfunction subTest(name, test) {\n    currentTest.subTests.push(function () {\n        output('\\n***', name);\n        return Promise.resolve().then(test).catch(_handleUnexpectedRejection);\n    });\n}\n\nfunction runTests(filter, resultsPath) {\n    cancelRun = false;\n    testsEnv.startRun(resultsPath);\n    return Promise.each(tests, function (aTest) {\n        if (cancelRun || filter && !_includeTest(filter, aTest)) return;\n\n        currentTest = aTest;\n        currentTest.output = '';\n        currentTest.subTests = [];\n        testsEnv.startTest(currentTest);\n        return runTest(currentTest.testFunc).then(function () {\n            return Promise.each(currentTest.subTests, runTest);\n        }).catch(_handleUnexpectedRejection).tap(testsEnv.writeTmpResult).then(testsEnv.getAcceptedResult).catch(reason => undefined).then(_compareResultToAccepted).then(testsEnv.handleResult);\n    });\n}\n\nfunction runTest(testFunc) {\n    return Promise.resolve().then(testFunc).catch(_handleUnexpectedRejection);\n}\n\nfunction cancelTests() {\n    cancelRun = true;\n}\n\nfunction listTests(filter) {\n    getTests(filter).forEach(testsEnv.list);\n}\n\nfunction getTests(filter) {\n    if (!filter) return tests;\n    return tests.filter(_includeTest.bind(null, filter));\n}\n\nvar _includeTest = function (filter, test) {\n    var testName = test.name;\n    return testName.match(filter) != null;\n};\n\nfunction _handleUnexpectedRejection(reason) {\n    var error = reason instanceof Error ? reason : new Error(reason.msg || reason);\n\n    if (document && document.location && document.location.search && document.location.search.indexOf(\"spec=\") >= 0) {\n        //individual test run              \n        if (document.location.search.indexOf(\"catch=false\") >= 0) {\n            throw error;\n        } else {\n            console.log(error.stack);\n            _outputErrorStack(error);\n        }\n    } else {\n        //full run (node or browser)\n        _outputErrorStack(error);\n    }\n}\n\nfunction _outputErrorStack(error) {\n    if (error.stack && error.stack.indexOf(\"From previous event\") >= 0) {\n        //include full stack as it will include the line that originated the error\n        _.each(error.stack.split('\\n'), function (line) {\n            output(line);\n        });\n    } else {\n        //no need to clutter output since it won't include the request's origin\n        output(\"Error: \" + error.message);\n    }\n}\n\nfunction _stringify(obj, indentLvl) {\n    var type = Object.prototype.toString.call(obj);\n    indentLvl = indentLvl || 1;\n    var indent = new Array(indentLvl + 1).join('\\t'),\n        indentClose = new Array(indentLvl).join('\\t');\n    if (type === '[object Object]') {\n        var pairs = [];\n        for (var k in obj) {\n            if (!obj.hasOwnProperty(k)) continue;\n            pairs.push([k, _stringify(obj[k], indentLvl + 1)]);\n        }\n        pairs.sort(function (a, b) {\n            return a[0] < b[0] ? -1 : 1;\n        });\n        pairs = _.reduce(pairs, function (m, v, i) {\n            return (i ? m + ',\\n' : '') + indent + '\"' + v[0] + '\": ' + v[1];\n        }, '');\n        return '{\\n' + pairs + '\\n' + indentClose + '}';\n    } else if (type === '[object Array]') {\n        return '[\\n' + _.reduce(obj, function (m, v, i) {\n            return (i ? m + ',\\n' : '') + indent + _stringify(v, indentLvl + 1);\n        }, '') + '\\n' + indentClose + ']';\n    } else if (type === '[object Number]') {\n        if (obj.toString().length > 13 || Math.abs(obj) > 1.0e+12) {\n            return parseFloat(obj.toPrecision(12)).toString();\n        }\n        return obj.toString();\n    }\n\n    return JSON.stringify(obj, null, '\\t');\n}\n\nfunction _compareResultToAccepted(expected) {\n    const actual = currentTest.output;\n    let fullContext = false;\n\n    if (!expected) {\n        var message = 'No accepted output (' + testsEnv.getAcceptedResultPath() + ')';\n        if (fullContext) message += '. Output: \\n' + actual;\n        return { pass: false, message: message };\n    }\n\n    var comparison = diff(actual.split(/\\r?\\n/), expected.split(/\\r?\\n/));\n    var diffs = _.filter(comparison, function (aDiff) {\n        return aDiff.operation == \"add\" || aDiff.operation == \"delete\";\n    });\n    var result = {\n        pass: diffs.length === 0,\n        message: ''\n    };\n    if (result.pass) {\n        result.message = \"output is equal to accepted output\";\n    } else {\n        var lineDiffs = [];\n        _.each(fullContext ? comparison : diffs, function (aDiff) {\n            if (aDiff.operation == \"add\") {\n                lineDiffs.push('-  ' + aDiff.atom);\n            } else if (aDiff.operation == \"delete\") {\n                lineDiffs.push('+  ' + aDiff.atom);\n            } else if (aDiff.atom) {\n                lineDiffs.push('   ' + aDiff.atom);\n            } else {\n                lineDiffs.push('   ' + aDiff);\n            }\n        });\n        result.message = \"Expected output to match accepted output:\\n\" + lineDiffs.join('\\n');\n        result.diffs = diffs;\n        result.comparison = comparison;\n    }\n    return result;\n}\n\n//these functions will be exposed as globals\nconst framework = {\n    suite,\n    test,\n    tests,\n    output,\n    subTest,\n    section,\n    cancelTests\n};\nObject.assign(global, framework);\nglobal.jo = framework;\n\nmodule.exports = Object.assign(framework, {\n    runTests,\n    listTests\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://jo/./src/main.js?");

/***/ }),

/***/ "./src/nodeEnv.js":
/*!************************!*\
  !*** ./src/nodeEnv.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const fs = __webpack_require__(/*! fs */ \"./node_modules/node-libs-browser/mock/empty.js\");\nconst os = __webpack_require__(/*! os */ \"./node_modules/os-browserify/browser.js\");\nconst path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\nconst tmpdir = os.tmpdir();\nlet resultsPath = 'results';\n\nlet currentTest;\n\nfunction startRun(lResultsPath) {\n\t\t\t\tif (lResultsPath) resultsPath = lResultsPath;\n\t\t\t\tconsole.log(\"Temp directory: \", tmpdir);\n}\n\nfunction startTest(test) {\n\t\t\t\tcurrentTest = test;\n}\n\nfunction writeTmpResult(currentTestOutput) {\n\t\t\t\tlet resultFilePath = path.join(tmpdir, currentTest.filename + '.txt');\n\t\t\t\tfs.writeFileSync(resultFilePath, currentTest.output);\n}\n\nfunction getAcceptedResult() {\n\t\t\t\tconst acceptedFilePath = getAcceptedResultPath();\n\t\t\t\tlet acceptedOutput;\n\n\t\t\t\ttry {\n\t\t\t\t\t\t\t\tacceptedOutput = fs.readFileSync(acceptedFilePath, 'utf-8');\n\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\tconsole.log(error);\n\t\t\t\t}\n\t\t\t\treturn Promise.resolve(acceptedOutput);\n}\n\nfunction getAcceptedResultPath() {\n\t\t\t\treturn path.resolve(resultsPath, currentTest.filename + '.txt');\n}\n\nfunction handleResult(result) {\n\t\t\t\tif (result.pass) {\n\t\t\t\t\t\t\t\tconsole.log(currentTest.name + ': PASSED');\n\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconsole.log(currentTest.name + ':\\t' + result.message.slice(0, 180));\n\t\t\t\t\t\t\t\tconsole.log(currentTest.name + ': FAILED');\n\t\t\t\t}\n}\n\nfunction list(test) {\n\t\t\t\tconsole.log('test:', test.filename);\n}\n\nmodule.exports = {\n\t\t\t\tstartRun,\n\t\t\t\tstartTest,\n\t\t\t\twriteTmpResult,\n\t\t\t\tgetAcceptedResultPath,\n\t\t\t\tgetAcceptedResult,\n\t\t\t\thandleResult,\n\t\t\t\tlist\n};\n\n//# sourceURL=webpack://jo/./src/nodeEnv.js?");

/***/ })

/******/ });
});